diff --git a/node_modules/@jimp/core/es/composite/composite-modes.js b/node_modules/@jimp/core/es/composite/composite-modes.js
index eee30ef..2b9ce96 100644
--- a/node_modules/@jimp/core/es/composite/composite-modes.js
+++ b/node_modules/@jimp/core/es/composite/composite-modes.js
@@ -1,236 +1,291 @@
-"use strict";
-
-Object.defineProperty(exports, "__esModule", {
-  value: true
-});
-exports.srcOver = srcOver;
-exports.dstOver = dstOver;
-exports.multiply = multiply;
-exports.add = add;
-exports.screen = screen;
-exports.overlay = overlay;
-exports.darken = darken;
-exports.lighten = lighten;
-exports.hardLight = hardLight;
-exports.difference = difference;
-exports.exclusion = exclusion;
-
-function srcOver(src, dst) {
-  var ops = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
+export function srcOver(src, dst, ops = 1) {
   src.a *= ops;
-  var a = dst.a + src.a - dst.a * src.a;
-  var r = (src.r * src.a + dst.r * dst.a * (1 - src.a)) / a;
-  var g = (src.g * src.a + dst.g * dst.a * (1 - src.a)) / a;
-  var b = (src.b * src.a + dst.b * dst.a * (1 - src.a)) / a;
-  return {
-    r: r,
-    g: g,
-    b: b,
-    a: a
-  };
+
+  const a = dst.a + src.a - dst.a * src.a;
+
+  const r = (src.r * src.a + dst.r * dst.a * (1 - src.a)) / a;
+  const g = (src.g * src.a + dst.g * dst.a * (1 - src.a)) / a;
+  const b = (src.b * src.a + dst.b * dst.a * (1 - src.a)) / a;
+
+  return { r, g, b, a };
 }
 
-function dstOver(src, dst) {
-  var ops = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
+export function dstOver(src, dst, ops = 1) {
   src.a *= ops;
-  var a = dst.a + src.a - dst.a * src.a;
-  var r = (dst.r * dst.a + src.r * src.a * (1 - dst.a)) / a;
-  var g = (dst.g * dst.a + src.g * src.a * (1 - dst.a)) / a;
-  var b = (dst.b * dst.a + src.b * src.a * (1 - dst.a)) / a;
-  return {
-    r: r,
-    g: g,
-    b: b,
-    a: a
-  };
+
+  const a = dst.a + src.a - dst.a * src.a;
+
+  const r = (dst.r * dst.a + src.r * src.a * (1 - dst.a)) / a;
+  const g = (dst.g * dst.a + src.g * src.a * (1 - dst.a)) / a;
+  const b = (dst.b * dst.a + src.b * src.a * (1 - dst.a)) / a;
+
+  return { r, g, b, a };
 }
 
-function multiply(src, dst) {
-  var ops = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
+export function multiply(src, dst, ops = 1) {
   src.a *= ops;
-  var a = dst.a + src.a - dst.a * src.a;
-  var sra = src.r * src.a;
-  var sga = src.g * src.a;
-  var sba = src.b * src.a;
-  var dra = dst.r * dst.a;
-  var dga = dst.g * dst.a;
-  var dba = dst.b * dst.a;
-  var r = (sra * dra + sra * (1 - dst.a) + dra * (1 - src.a)) / a;
-  var g = (sga * dga + sga * (1 - dst.a) + dga * (1 - src.a)) / a;
-  var b = (sba * dba + sba * (1 - dst.a) + dba * (1 - src.a)) / a;
-  return {
-    r: r,
-    g: g,
-    b: b,
-    a: a
-  };
+
+  const a = dst.a + src.a - dst.a * src.a;
+
+  const sra = src.r * src.a;
+  const sga = src.g * src.a;
+  const sba = src.b * src.a;
+
+  const dra = dst.r * dst.a;
+  const dga = dst.g * dst.a;
+  const dba = dst.b * dst.a;
+
+  const r = (sra * dra + sra * (1 - dst.a) + dra * (1 - src.a)) / a;
+  const g = (sga * dga + sga * (1 - dst.a) + dga * (1 - src.a)) / a;
+  const b = (sba * dba + sba * (1 - dst.a) + dba * (1 - src.a)) / a;
+
+  return { r, g, b, a };
 }
 
-function add(src, dst) {
-  var ops = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
+export function add(src, dst, ops = 1) {
   src.a *= ops;
-  var a = dst.a + src.a - dst.a * src.a;
-  var sra = src.r * src.a;
-  var sga = src.g * src.a;
-  var sba = src.b * src.a;
-  var dra = dst.r * dst.a;
-  var dga = dst.g * dst.a;
-  var dba = dst.b * dst.a;
-  var r = (sra + dra) / a;
-  var g = (sga + dga) / a;
-  var b = (sba + dba) / a;
-  return {
-    r: r,
-    g: g,
-    b: b,
-    a: a
-  };
+
+  const a = dst.a + src.a - dst.a * src.a;
+
+  const sra = src.r * src.a;
+  const sga = src.g * src.a;
+  const sba = src.b * src.a;
+
+  const dra = dst.r * dst.a;
+  const dga = dst.g * dst.a;
+  const dba = dst.b * dst.a;
+
+  const r = (sra + dra) / a;
+  const g = (sga + dga) / a;
+  const b = (sba + dba) / a;
+
+  return { r, g, b, a };
 }
 
-function screen(src, dst) {
-  var ops = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
+export function screen(src, dst, ops = 1) {
   src.a *= ops;
-  var a = dst.a + src.a - dst.a * src.a;
-  var sra = src.r * src.a;
-  var sga = src.g * src.a;
-  var sba = src.b * src.a;
-  var dra = dst.r * dst.a;
-  var dga = dst.g * dst.a;
-  var dba = dst.b * dst.a;
-  var r = (sra * dst.a + dra * src.a - sra * dra + sra * (1 - dst.a) + dra * (1 - src.a)) / a;
-  var g = (sga * dst.a + dga * src.a - sga * dga + sga * (1 - dst.a) + dga * (1 - src.a)) / a;
-  var b = (sba * dst.a + dba * src.a - sba * dba + sba * (1 - dst.a) + dba * (1 - src.a)) / a;
-  return {
-    r: r,
-    g: g,
-    b: b,
-    a: a
-  };
+
+  const a = dst.a + src.a - dst.a * src.a;
+
+  const sra = src.r * src.a;
+  const sga = src.g * src.a;
+  const sba = src.b * src.a;
+
+  const dra = dst.r * dst.a;
+  const dga = dst.g * dst.a;
+  const dba = dst.b * dst.a;
+
+  const r =
+    (sra * dst.a +
+      dra * src.a -
+      sra * dra +
+      sra * (1 - dst.a) +
+      dra * (1 - src.a)) /
+    a;
+  const g =
+    (sga * dst.a +
+      dga * src.a -
+      sga * dga +
+      sga * (1 - dst.a) +
+      dga * (1 - src.a)) /
+    a;
+  const b =
+    (sba * dst.a +
+      dba * src.a -
+      sba * dba +
+      sba * (1 - dst.a) +
+      dba * (1 - src.a)) /
+    a;
+
+  return { r, g, b, a };
 }
 
-function overlay(src, dst) {
-  var ops = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
+export function overlay(src, dst, ops = 1) {
   src.a *= ops;
-  var a = dst.a + src.a - dst.a * src.a;
-  var sra = src.r * src.a;
-  var sga = src.g * src.a;
-  var sba = src.b * src.a;
-  var dra = dst.r * dst.a;
-  var dga = dst.g * dst.a;
-  var dba = dst.b * dst.a;
-  var r = (2 * dra <= dst.a ? 2 * sra * dra + sra * (1 - dst.a) + dra * (1 - src.a) : sra * (1 + dst.a) + dra * (1 + src.a) - 2 * dra * sra - dst.a * src.a) / a;
-  var g = (2 * dga <= dst.a ? 2 * sga * dga + sga * (1 - dst.a) + dga * (1 - src.a) : sga * (1 + dst.a) + dga * (1 + src.a) - 2 * dga * sga - dst.a * src.a) / a;
-  var b = (2 * dba <= dst.a ? 2 * sba * dba + sba * (1 - dst.a) + dba * (1 - src.a) : sba * (1 + dst.a) + dba * (1 + src.a) - 2 * dba * sba - dst.a * src.a) / a;
-  return {
-    r: r,
-    g: g,
-    b: b,
-    a: a
-  };
+
+  const a = dst.a + src.a - dst.a * src.a;
+
+  const sra = src.r * src.a;
+  const sga = src.g * src.a;
+  const sba = src.b * src.a;
+
+  const dra = dst.r * dst.a;
+  const dga = dst.g * dst.a;
+  const dba = dst.b * dst.a;
+
+  const r =
+    (2 * dra <= dst.a
+      ? 2 * sra * dra + sra * (1 - dst.a) + dra * (1 - src.a)
+      : sra * (1 + dst.a) + dra * (1 + src.a) - 2 * dra * sra - dst.a * src.a) /
+    a;
+
+  const g =
+    (2 * dga <= dst.a
+      ? 2 * sga * dga + sga * (1 - dst.a) + dga * (1 - src.a)
+      : sga * (1 + dst.a) + dga * (1 + src.a) - 2 * dga * sga - dst.a * src.a) /
+    a;
+
+  const b =
+    (2 * dba <= dst.a
+      ? 2 * sba * dba + sba * (1 - dst.a) + dba * (1 - src.a)
+      : sba * (1 + dst.a) + dba * (1 + src.a) - 2 * dba * sba - dst.a * src.a) /
+    a;
+
+  return { r, g, b, a };
 }
 
-function darken(src, dst) {
-  var ops = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
+export function darken(src, dst, ops = 1) {
   src.a *= ops;
-  var a = dst.a + src.a - dst.a * src.a;
-  var sra = src.r * src.a;
-  var sga = src.g * src.a;
-  var sba = src.b * src.a;
-  var dra = dst.r * dst.a;
-  var dga = dst.g * dst.a;
-  var dba = dst.b * dst.a;
-  var r = (Math.min(sra * dst.a, dra * src.a) + sra * (1 - dst.a) + dra * (1 - src.a)) / a;
-  var g = (Math.min(sga * dst.a, dga * src.a) + sga * (1 - dst.a) + dga * (1 - src.a)) / a;
-  var b = (Math.min(sba * dst.a, dba * src.a) + sba * (1 - dst.a) + dba * (1 - src.a)) / a;
-  return {
-    r: r,
-    g: g,
-    b: b,
-    a: a
-  };
+
+  const a = dst.a + src.a - dst.a * src.a;
+
+  const sra = src.r * src.a;
+  const sga = src.g * src.a;
+  const sba = src.b * src.a;
+
+  const dra = dst.r * dst.a;
+  const dga = dst.g * dst.a;
+  const dba = dst.b * dst.a;
+
+  const r =
+    (Math.min(sra * dst.a, dra * src.a) +
+      sra * (1 - dst.a) +
+      dra * (1 - src.a)) /
+    a;
+  const g =
+    (Math.min(sga * dst.a, dga * src.a) +
+      sga * (1 - dst.a) +
+      dga * (1 - src.a)) /
+    a;
+  const b =
+    (Math.min(sba * dst.a, dba * src.a) +
+      sba * (1 - dst.a) +
+      dba * (1 - src.a)) /
+    a;
+
+  return { r, g, b, a };
 }
 
-function lighten(src, dst) {
-  var ops = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
+export function lighten(src, dst, ops = 1) {
   src.a *= ops;
-  var a = dst.a + src.a - dst.a * src.a;
-  var sra = src.r * src.a;
-  var sga = src.g * src.a;
-  var sba = src.b * src.a;
-  var dra = dst.r * dst.a;
-  var dga = dst.g * dst.a;
-  var dba = dst.b * dst.a;
-  var r = (Math.max(sra * dst.a, dra * src.a) + sra * (1 - dst.a) + dra * (1 - src.a)) / a;
-  var g = (Math.max(sga * dst.a, dga * src.a) + sga * (1 - dst.a) + dga * (1 - src.a)) / a;
-  var b = (Math.max(sba * dst.a, dba * src.a) + sba * (1 - dst.a) + dba * (1 - src.a)) / a;
-  return {
-    r: r,
-    g: g,
-    b: b,
-    a: a
-  };
+
+  const a = dst.a + src.a - dst.a * src.a;
+
+  const sra = src.r * src.a;
+  const sga = src.g * src.a;
+  const sba = src.b * src.a;
+
+  const dra = dst.r * dst.a;
+  const dga = dst.g * dst.a;
+  const dba = dst.b * dst.a;
+
+  const r =
+    (Math.max(sra * dst.a, dra * src.a) +
+      sra * (1 - dst.a) +
+      dra * (1 - src.a)) /
+    a;
+  const g =
+    (Math.max(sga * dst.a, dga * src.a) +
+      sga * (1 - dst.a) +
+      dga * (1 - src.a)) /
+    a;
+  const b =
+    (Math.max(sba * dst.a, dba * src.a) +
+      sba * (1 - dst.a) +
+      dba * (1 - src.a)) /
+    a;
+
+  return { r, g, b, a };
 }
 
-function hardLight(src, dst) {
-  var ops = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
+export function hardLight(src, dst, ops = 1) {
   src.a *= ops;
-  var a = dst.a + src.a - dst.a * src.a;
-  var sra = src.r * src.a;
-  var sga = src.g * src.a;
-  var sba = src.b * src.a;
-  var dra = dst.r * dst.a;
-  var dga = dst.g * dst.a;
-  var dba = dst.b * dst.a;
-  var r = (2 * sra <= src.a ? 2 * sra * dra + sra * (1 - dst.a) + dra * (1 - src.a) : sra * (1 + dst.a) + dra * (1 + src.a) - 2 * dra * sra - dst.a * src.a) / a;
-  var g = (2 * sga <= src.a ? 2 * sga * dga + sga * (1 - dst.a) + dga * (1 - src.a) : sga * (1 + dst.a) + dga * (1 + src.a) - 2 * dga * sga - dst.a * src.a) / a;
-  var b = (2 * sba <= src.a ? 2 * sba * dba + sba * (1 - dst.a) + dba * (1 - src.a) : sba * (1 + dst.a) + dba * (1 + src.a) - 2 * dba * sba - dst.a * src.a) / a;
-  return {
-    r: r,
-    g: g,
-    b: b,
-    a: a
-  };
+
+  const a = dst.a + src.a - dst.a * src.a;
+
+  const sra = src.r * src.a;
+  const sga = src.g * src.a;
+  const sba = src.b * src.a;
+
+  const dra = dst.r * dst.a;
+  const dga = dst.g * dst.a;
+  const dba = dst.b * dst.a;
+
+  const r =
+    (2 * sra <= src.a
+      ? 2 * sra * dra + sra * (1 - dst.a) + dra * (1 - src.a)
+      : sra * (1 + dst.a) + dra * (1 + src.a) - 2 * dra * sra - dst.a * src.a) /
+    a;
+
+  const g =
+    (2 * sga <= src.a
+      ? 2 * sga * dga + sga * (1 - dst.a) + dga * (1 - src.a)
+      : sga * (1 + dst.a) + dga * (1 + src.a) - 2 * dga * sga - dst.a * src.a) /
+    a;
+
+  const b =
+    (2 * sba <= src.a
+      ? 2 * sba * dba + sba * (1 - dst.a) + dba * (1 - src.a)
+      : sba * (1 + dst.a) + dba * (1 + src.a) - 2 * dba * sba - dst.a * src.a) /
+    a;
+
+  return { r, g, b, a };
 }
 
-function difference(src, dst) {
-  var ops = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
+export function difference(src, dst, ops = 1) {
   src.a *= ops;
-  var a = dst.a + src.a - dst.a * src.a;
-  var sra = src.r * src.a;
-  var sga = src.g * src.a;
-  var sba = src.b * src.a;
-  var dra = dst.r * dst.a;
-  var dga = dst.g * dst.a;
-  var dba = dst.b * dst.a;
-  var r = (sra + dra - 2 * Math.min(sra * dst.a, dra * src.a)) / a;
-  var g = (sga + dga - 2 * Math.min(sga * dst.a, dga * src.a)) / a;
-  var b = (sba + dba - 2 * Math.min(sba * dst.a, dba * src.a)) / a;
-  return {
-    r: r,
-    g: g,
-    b: b,
-    a: a
-  };
+
+  const a = dst.a + src.a - dst.a * src.a;
+
+  const sra = src.r * src.a;
+  const sga = src.g * src.a;
+  const sba = src.b * src.a;
+
+  const dra = dst.r * dst.a;
+  const dga = dst.g * dst.a;
+  const dba = dst.b * dst.a;
+
+  const r = (sra + dra - 2 * Math.min(sra * dst.a, dra * src.a)) / a;
+  const g = (sga + dga - 2 * Math.min(sga * dst.a, dga * src.a)) / a;
+  const b = (sba + dba - 2 * Math.min(sba * dst.a, dba * src.a)) / a;
+
+  return { r, g, b, a };
 }
 
-function exclusion(src, dst) {
-  var ops = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
+export function exclusion(src, dst, ops = 1) {
   src.a *= ops;
-  var a = dst.a + src.a - dst.a * src.a;
-  var sra = src.r * src.a;
-  var sga = src.g * src.a;
-  var sba = src.b * src.a;
-  var dra = dst.r * dst.a;
-  var dga = dst.g * dst.a;
-  var dba = dst.b * dst.a;
-  var r = (sra * dst.a + dra * src.a - 2 * sra * dra + sra * (1 - dst.a) + dra * (1 - src.a)) / a;
-  var g = (sga * dst.a + dga * src.a - 2 * sga * dga + sga * (1 - dst.a) + dga * (1 - src.a)) / a;
-  var b = (sba * dst.a + dba * src.a - 2 * sba * dba + sba * (1 - dst.a) + dba * (1 - src.a)) / a;
-  return {
-    r: r,
-    g: g,
-    b: b,
-    a: a
-  };
+
+  const a = dst.a + src.a - dst.a * src.a;
+
+  const sra = src.r * src.a;
+  const sga = src.g * src.a;
+  const sba = src.b * src.a;
+
+  const dra = dst.r * dst.a;
+  const dga = dst.g * dst.a;
+  const dba = dst.b * dst.a;
+
+  const r =
+    (sra * dst.a +
+      dra * src.a -
+      2 * sra * dra +
+      sra * (1 - dst.a) +
+      dra * (1 - src.a)) /
+    a;
+  const g =
+    (sga * dst.a +
+      dga * src.a -
+      2 * sga * dga +
+      sga * (1 - dst.a) +
+      dga * (1 - src.a)) /
+    a;
+  const b =
+    (sba * dst.a +
+      dba * src.a -
+      2 * sba * dba +
+      sba * (1 - dst.a) +
+      dba * (1 - src.a)) /
+    a;
+
+  return { r, g, b, a };
 }
-//# sourceMappingURL=composite-modes.js.map
\ No newline at end of file
diff --git a/node_modules/@jimp/core/es/composite/composite-modes.js.map b/node_modules/@jimp/core/es/composite/composite-modes.js.map
deleted file mode 100644
index 2d24ac8..0000000
--- a/node_modules/@jimp/core/es/composite/composite-modes.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"sources":["../../src/composite/composite-modes.js"],"names":["srcOver","src","dst","ops","a","r","g","b","dstOver","multiply","sra","sga","sba","dra","dga","dba","add","screen","overlay","darken","Math","min","lighten","max","hardLight","difference","exclusion"],"mappings":"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","sourcesContent":["export function srcOver(src, dst, ops = 1) {\n  src.a *= ops;\n\n  const a = dst.a + src.a - dst.a * src.a;\n\n  const r = (src.r * src.a + dst.r * dst.a * (1 - src.a)) / a;\n  const g = (src.g * src.a + dst.g * dst.a * (1 - src.a)) / a;\n  const b = (src.b * src.a + dst.b * dst.a * (1 - src.a)) / a;\n\n  return { r, g, b, a };\n}\n\nexport function dstOver(src, dst, ops = 1) {\n  src.a *= ops;\n\n  const a = dst.a + src.a - dst.a * src.a;\n\n  const r = (dst.r * dst.a + src.r * src.a * (1 - dst.a)) / a;\n  const g = (dst.g * dst.a + src.g * src.a * (1 - dst.a)) / a;\n  const b = (dst.b * dst.a + src.b * src.a * (1 - dst.a)) / a;\n\n  return { r, g, b, a };\n}\n\nexport function multiply(src, dst, ops = 1) {\n  src.a *= ops;\n\n  const a = dst.a + src.a - dst.a * src.a;\n\n  const sra = src.r * src.a;\n  const sga = src.g * src.a;\n  const sba = src.b * src.a;\n\n  const dra = dst.r * dst.a;\n  const dga = dst.g * dst.a;\n  const dba = dst.b * dst.a;\n\n  const r = (sra * dra + sra * (1 - dst.a) + dra * (1 - src.a)) / a;\n  const g = (sga * dga + sga * (1 - dst.a) + dga * (1 - src.a)) / a;\n  const b = (sba * dba + sba * (1 - dst.a) + dba * (1 - src.a)) / a;\n\n  return { r, g, b, a };\n}\n\nexport function add(src, dst, ops = 1) {\n  src.a *= ops;\n\n  const a = dst.a + src.a - dst.a * src.a;\n\n  const sra = src.r * src.a;\n  const sga = src.g * src.a;\n  const sba = src.b * src.a;\n\n  const dra = dst.r * dst.a;\n  const dga = dst.g * dst.a;\n  const dba = dst.b * dst.a;\n\n  const r = (sra + dra) / a;\n  const g = (sga + dga) / a;\n  const b = (sba + dba) / a;\n\n  return { r, g, b, a };\n}\n\nexport function screen(src, dst, ops = 1) {\n  src.a *= ops;\n\n  const a = dst.a + src.a - dst.a * src.a;\n\n  const sra = src.r * src.a;\n  const sga = src.g * src.a;\n  const sba = src.b * src.a;\n\n  const dra = dst.r * dst.a;\n  const dga = dst.g * dst.a;\n  const dba = dst.b * dst.a;\n\n  const r =\n    (sra * dst.a +\n      dra * src.a -\n      sra * dra +\n      sra * (1 - dst.a) +\n      dra * (1 - src.a)) /\n    a;\n  const g =\n    (sga * dst.a +\n      dga * src.a -\n      sga * dga +\n      sga * (1 - dst.a) +\n      dga * (1 - src.a)) /\n    a;\n  const b =\n    (sba * dst.a +\n      dba * src.a -\n      sba * dba +\n      sba * (1 - dst.a) +\n      dba * (1 - src.a)) /\n    a;\n\n  return { r, g, b, a };\n}\n\nexport function overlay(src, dst, ops = 1) {\n  src.a *= ops;\n\n  const a = dst.a + src.a - dst.a * src.a;\n\n  const sra = src.r * src.a;\n  const sga = src.g * src.a;\n  const sba = src.b * src.a;\n\n  const dra = dst.r * dst.a;\n  const dga = dst.g * dst.a;\n  const dba = dst.b * dst.a;\n\n  const r =\n    (2 * dra <= dst.a\n      ? 2 * sra * dra + sra * (1 - dst.a) + dra * (1 - src.a)\n      : sra * (1 + dst.a) + dra * (1 + src.a) - 2 * dra * sra - dst.a * src.a) /\n    a;\n\n  const g =\n    (2 * dga <= dst.a\n      ? 2 * sga * dga + sga * (1 - dst.a) + dga * (1 - src.a)\n      : sga * (1 + dst.a) + dga * (1 + src.a) - 2 * dga * sga - dst.a * src.a) /\n    a;\n\n  const b =\n    (2 * dba <= dst.a\n      ? 2 * sba * dba + sba * (1 - dst.a) + dba * (1 - src.a)\n      : sba * (1 + dst.a) + dba * (1 + src.a) - 2 * dba * sba - dst.a * src.a) /\n    a;\n\n  return { r, g, b, a };\n}\n\nexport function darken(src, dst, ops = 1) {\n  src.a *= ops;\n\n  const a = dst.a + src.a - dst.a * src.a;\n\n  const sra = src.r * src.a;\n  const sga = src.g * src.a;\n  const sba = src.b * src.a;\n\n  const dra = dst.r * dst.a;\n  const dga = dst.g * dst.a;\n  const dba = dst.b * dst.a;\n\n  const r =\n    (Math.min(sra * dst.a, dra * src.a) +\n      sra * (1 - dst.a) +\n      dra * (1 - src.a)) /\n    a;\n  const g =\n    (Math.min(sga * dst.a, dga * src.a) +\n      sga * (1 - dst.a) +\n      dga * (1 - src.a)) /\n    a;\n  const b =\n    (Math.min(sba * dst.a, dba * src.a) +\n      sba * (1 - dst.a) +\n      dba * (1 - src.a)) /\n    a;\n\n  return { r, g, b, a };\n}\n\nexport function lighten(src, dst, ops = 1) {\n  src.a *= ops;\n\n  const a = dst.a + src.a - dst.a * src.a;\n\n  const sra = src.r * src.a;\n  const sga = src.g * src.a;\n  const sba = src.b * src.a;\n\n  const dra = dst.r * dst.a;\n  const dga = dst.g * dst.a;\n  const dba = dst.b * dst.a;\n\n  const r =\n    (Math.max(sra * dst.a, dra * src.a) +\n      sra * (1 - dst.a) +\n      dra * (1 - src.a)) /\n    a;\n  const g =\n    (Math.max(sga * dst.a, dga * src.a) +\n      sga * (1 - dst.a) +\n      dga * (1 - src.a)) /\n    a;\n  const b =\n    (Math.max(sba * dst.a, dba * src.a) +\n      sba * (1 - dst.a) +\n      dba * (1 - src.a)) /\n    a;\n\n  return { r, g, b, a };\n}\n\nexport function hardLight(src, dst, ops = 1) {\n  src.a *= ops;\n\n  const a = dst.a + src.a - dst.a * src.a;\n\n  const sra = src.r * src.a;\n  const sga = src.g * src.a;\n  const sba = src.b * src.a;\n\n  const dra = dst.r * dst.a;\n  const dga = dst.g * dst.a;\n  const dba = dst.b * dst.a;\n\n  const r =\n    (2 * sra <= src.a\n      ? 2 * sra * dra + sra * (1 - dst.a) + dra * (1 - src.a)\n      : sra * (1 + dst.a) + dra * (1 + src.a) - 2 * dra * sra - dst.a * src.a) /\n    a;\n\n  const g =\n    (2 * sga <= src.a\n      ? 2 * sga * dga + sga * (1 - dst.a) + dga * (1 - src.a)\n      : sga * (1 + dst.a) + dga * (1 + src.a) - 2 * dga * sga - dst.a * src.a) /\n    a;\n\n  const b =\n    (2 * sba <= src.a\n      ? 2 * sba * dba + sba * (1 - dst.a) + dba * (1 - src.a)\n      : sba * (1 + dst.a) + dba * (1 + src.a) - 2 * dba * sba - dst.a * src.a) /\n    a;\n\n  return { r, g, b, a };\n}\n\nexport function difference(src, dst, ops = 1) {\n  src.a *= ops;\n\n  const a = dst.a + src.a - dst.a * src.a;\n\n  const sra = src.r * src.a;\n  const sga = src.g * src.a;\n  const sba = src.b * src.a;\n\n  const dra = dst.r * dst.a;\n  const dga = dst.g * dst.a;\n  const dba = dst.b * dst.a;\n\n  const r = (sra + dra - 2 * Math.min(sra * dst.a, dra * src.a)) / a;\n  const g = (sga + dga - 2 * Math.min(sga * dst.a, dga * src.a)) / a;\n  const b = (sba + dba - 2 * Math.min(sba * dst.a, dba * src.a)) / a;\n\n  return { r, g, b, a };\n}\n\nexport function exclusion(src, dst, ops = 1) {\n  src.a *= ops;\n\n  const a = dst.a + src.a - dst.a * src.a;\n\n  const sra = src.r * src.a;\n  const sga = src.g * src.a;\n  const sba = src.b * src.a;\n\n  const dra = dst.r * dst.a;\n  const dga = dst.g * dst.a;\n  const dba = dst.b * dst.a;\n\n  const r =\n    (sra * dst.a +\n      dra * src.a -\n      2 * sra * dra +\n      sra * (1 - dst.a) +\n      dra * (1 - src.a)) /\n    a;\n  const g =\n    (sga * dst.a +\n      dga * src.a -\n      2 * sga * dga +\n      sga * (1 - dst.a) +\n      dga * (1 - src.a)) /\n    a;\n  const b =\n    (sba * dst.a +\n      dba * src.a -\n      2 * sba * dba +\n      sba * (1 - dst.a) +\n      dba * (1 - src.a)) /\n    a;\n\n  return { r, g, b, a };\n}\n"],"file":"composite-modes.js"}
\ No newline at end of file
diff --git a/node_modules/@jimp/core/es/composite/index.js b/node_modules/@jimp/core/es/composite/index.js
index cd3165d..cdf4f82 100644
--- a/node_modules/@jimp/core/es/composite/index.js
+++ b/node_modules/@jimp/core/es/composite/index.js
@@ -1,17 +1,7 @@
-"use strict";
+import { isNodePattern, throwError } from '@jimp/utils';
+import * as constants from '../constants';
 
-var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");
-
-Object.defineProperty(exports, "__esModule", {
-  value: true
-});
-exports["default"] = composite;
-
-var _utils = require("@jimp/utils");
-
-var constants = _interopRequireWildcard(require("../constants"));
-
-var compositeModes = _interopRequireWildcard(require("./composite-modes"));
+import * as compositeModes from './composite-modes';
 
 /**
  * Composites a source image over to this image respecting alpha channels
@@ -22,33 +12,31 @@ var compositeModes = _interopRequireWildcard(require("./composite-modes"));
  * @param {function(Error, Jimp)} cb (optional) a callback for when complete
  * @returns {Jimp} this for chaining of methods
  */
-function composite(src, x, y) {
-  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
-  var cb = arguments.length > 4 ? arguments[4] : undefined;
-
+export default function composite(src, x, y, options = {}, cb) {
   if (typeof options === 'function') {
     cb = options;
     options = {};
   }
 
   if (!(src instanceof this.constructor)) {
-    return _utils.throwError.call(this, 'The source must be a Jimp image', cb);
+    return throwError.call(this, 'The source must be a Jimp image', cb);
   }
 
   if (typeof x !== 'number' || typeof y !== 'number') {
-    return _utils.throwError.call(this, 'x and y must be numbers', cb);
+    return throwError.call(this, 'x and y must be numbers', cb);
   }
 
-  var _options = options,
-      mode = _options.mode,
-      opacitySource = _options.opacitySource,
-      opacityDest = _options.opacityDest;
+  let { mode, opacitySource, opacityDest } = options;
 
   if (!mode) {
     mode = constants.BLEND_SOURCE_OVER;
   }
 
-  if (typeof opacitySource !== 'number' || opacitySource < 0 || opacitySource > 1) {
+  if (
+    typeof opacitySource !== 'number' ||
+    opacitySource < 0 ||
+    opacitySource > 1
+  ) {
     opacitySource = 1.0;
   }
 
@@ -56,39 +44,57 @@ function composite(src, x, y) {
     opacityDest = 1.0;
   }
 
-  var blendmode = compositeModes[mode]; // round input
+  const blendmode = compositeModes[mode];
 
+  // round input
   x = Math.round(x);
   y = Math.round(y);
-  var baseImage = this;
+
+  const baseImage = this;
 
   if (opacityDest !== 1.0) {
     baseImage.opacity(opacityDest);
   }
 
-  src.scanQuiet(0, 0, src.bitmap.width, src.bitmap.height, function (sx, sy, idx) {
-    var dstIdx = baseImage.getPixelIndex(x + sx, y + sy, constants.EDGE_CROP);
-    var blended = blendmode({
-      r: this.bitmap.data[idx + 0] / 255,
-      g: this.bitmap.data[idx + 1] / 255,
-      b: this.bitmap.data[idx + 2] / 255,
-      a: this.bitmap.data[idx + 3] / 255
-    }, {
-      r: baseImage.bitmap.data[dstIdx + 0] / 255,
-      g: baseImage.bitmap.data[dstIdx + 1] / 255,
-      b: baseImage.bitmap.data[dstIdx + 2] / 255,
-      a: baseImage.bitmap.data[dstIdx + 3] / 255
-    }, opacitySource);
-    baseImage.bitmap.data[dstIdx + 0] = this.constructor.limit255(blended.r * 255);
-    baseImage.bitmap.data[dstIdx + 1] = this.constructor.limit255(blended.g * 255);
-    baseImage.bitmap.data[dstIdx + 2] = this.constructor.limit255(blended.b * 255);
-    baseImage.bitmap.data[dstIdx + 3] = this.constructor.limit255(blended.a * 255);
+  src.scanQuiet(0, 0, src.bitmap.width, src.bitmap.height, function(
+    sx,
+    sy,
+    idx
+  ) {
+    const dstIdx = baseImage.getPixelIndex(x + sx, y + sy, constants.EDGE_CROP);
+    const blended = blendmode(
+      {
+        r: this.bitmap.data[idx + 0] / 255,
+        g: this.bitmap.data[idx + 1] / 255,
+        b: this.bitmap.data[idx + 2] / 255,
+        a: this.bitmap.data[idx + 3] / 255
+      },
+      {
+        r: baseImage.bitmap.data[dstIdx + 0] / 255,
+        g: baseImage.bitmap.data[dstIdx + 1] / 255,
+        b: baseImage.bitmap.data[dstIdx + 2] / 255,
+        a: baseImage.bitmap.data[dstIdx + 3] / 255
+      },
+      opacitySource
+    );
+
+    baseImage.bitmap.data[dstIdx + 0] = this.constructor.limit255(
+      blended.r * 255
+    );
+    baseImage.bitmap.data[dstIdx + 1] = this.constructor.limit255(
+      blended.g * 255
+    );
+    baseImage.bitmap.data[dstIdx + 2] = this.constructor.limit255(
+      blended.b * 255
+    );
+    baseImage.bitmap.data[dstIdx + 3] = this.constructor.limit255(
+      blended.a * 255
+    );
   });
 
-  if ((0, _utils.isNodePattern)(cb)) {
+  if (isNodePattern(cb)) {
     cb.call(this, null, this);
   }
 
   return this;
 }
-//# sourceMappingURL=index.js.map
\ No newline at end of file
diff --git a/node_modules/@jimp/core/es/composite/index.js.map b/node_modules/@jimp/core/es/composite/index.js.map
deleted file mode 100644
index 290d15e..0000000
--- a/node_modules/@jimp/core/es/composite/index.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"sources":["../../src/composite/index.js"],"names":["composite","src","x","y","options","cb","constructor","throwError","call","mode","opacitySource","opacityDest","constants","BLEND_SOURCE_OVER","blendmode","compositeModes","Math","round","baseImage","opacity","scanQuiet","bitmap","width","height","sx","sy","idx","dstIdx","getPixelIndex","EDGE_CROP","blended","r","data","g","b","a","limit255"],"mappings":"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","sourcesContent":["import { isNodePattern, throwError } from '@jimp/utils';\nimport * as constants from '../constants';\n\nimport * as compositeModes from './composite-modes';\n\n/**\n * Composites a source image over to this image respecting alpha channels\n * @param {Jimp} src the source Jimp instance\n * @param {number} x the x position to blit the image\n * @param {number} y the y position to blit the image\n * @param {object} options determine what mode to use\n * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n * @returns {Jimp} this for chaining of methods\n */\nexport default function composite(src, x, y, options = {}, cb) {\n  if (typeof options === 'function') {\n    cb = options;\n    options = {};\n  }\n\n  if (!(src instanceof this.constructor)) {\n    return throwError.call(this, 'The source must be a Jimp image', cb);\n  }\n\n  if (typeof x !== 'number' || typeof y !== 'number') {\n    return throwError.call(this, 'x and y must be numbers', cb);\n  }\n\n  let { mode, opacitySource, opacityDest } = options;\n\n  if (!mode) {\n    mode = constants.BLEND_SOURCE_OVER;\n  }\n\n  if (\n    typeof opacitySource !== 'number' ||\n    opacitySource < 0 ||\n    opacitySource > 1\n  ) {\n    opacitySource = 1.0;\n  }\n\n  if (typeof opacityDest !== 'number' || opacityDest < 0 || opacityDest > 1) {\n    opacityDest = 1.0;\n  }\n\n  const blendmode = compositeModes[mode];\n\n  // round input\n  x = Math.round(x);\n  y = Math.round(y);\n\n  const baseImage = this;\n\n  if (opacityDest !== 1.0) {\n    baseImage.opacity(opacityDest);\n  }\n\n  src.scanQuiet(0, 0, src.bitmap.width, src.bitmap.height, function(\n    sx,\n    sy,\n    idx\n  ) {\n    const dstIdx = baseImage.getPixelIndex(x + sx, y + sy, constants.EDGE_CROP);\n    const blended = blendmode(\n      {\n        r: this.bitmap.data[idx + 0] / 255,\n        g: this.bitmap.data[idx + 1] / 255,\n        b: this.bitmap.data[idx + 2] / 255,\n        a: this.bitmap.data[idx + 3] / 255\n      },\n      {\n        r: baseImage.bitmap.data[dstIdx + 0] / 255,\n        g: baseImage.bitmap.data[dstIdx + 1] / 255,\n        b: baseImage.bitmap.data[dstIdx + 2] / 255,\n        a: baseImage.bitmap.data[dstIdx + 3] / 255\n      },\n      opacitySource\n    );\n\n    baseImage.bitmap.data[dstIdx + 0] = this.constructor.limit255(\n      blended.r * 255\n    );\n    baseImage.bitmap.data[dstIdx + 1] = this.constructor.limit255(\n      blended.g * 255\n    );\n    baseImage.bitmap.data[dstIdx + 2] = this.constructor.limit255(\n      blended.b * 255\n    );\n    baseImage.bitmap.data[dstIdx + 3] = this.constructor.limit255(\n      blended.a * 255\n    );\n  });\n\n  if (isNodePattern(cb)) {\n    cb.call(this, null, this);\n  }\n\n  return this;\n}\n"],"file":"index.js"}
\ No newline at end of file
diff --git a/node_modules/@jimp/core/es/constants.js b/node_modules/@jimp/core/es/constants.js
index cc86acb..af819d6 100644
--- a/node_modules/@jimp/core/es/constants.js
+++ b/node_modules/@jimp/core/es/constants.js
@@ -1,53 +1,29 @@
-"use strict";
-
-Object.defineProperty(exports, "__esModule", {
-  value: true
-});
-exports.EDGE_CROP = exports.EDGE_WRAP = exports.EDGE_EXTEND = exports.BLEND_EXCLUSION = exports.BLEND_DIFFERENCE = exports.BLEND_HARDLIGHT = exports.BLEND_LIGHTEN = exports.BLEND_DARKEN = exports.BLEND_OVERLAY = exports.BLEND_SCREEN = exports.BLEND_ADD = exports.BLEND_MULTIPLY = exports.BLEND_DESTINATION_OVER = exports.BLEND_SOURCE_OVER = exports.VERTICAL_ALIGN_BOTTOM = exports.VERTICAL_ALIGN_MIDDLE = exports.VERTICAL_ALIGN_TOP = exports.HORIZONTAL_ALIGN_RIGHT = exports.HORIZONTAL_ALIGN_CENTER = exports.HORIZONTAL_ALIGN_LEFT = exports.AUTO = void 0;
 // used to auto resizing etc.
-var AUTO = -1; // Align modes for cover, contain, bit masks
+export const AUTO = -1;
+
+// Align modes for cover, contain, bit masks
+export const HORIZONTAL_ALIGN_LEFT = 1;
+export const HORIZONTAL_ALIGN_CENTER = 2;
+export const HORIZONTAL_ALIGN_RIGHT = 4;
 
-exports.AUTO = AUTO;
-var HORIZONTAL_ALIGN_LEFT = 1;
-exports.HORIZONTAL_ALIGN_LEFT = HORIZONTAL_ALIGN_LEFT;
-var HORIZONTAL_ALIGN_CENTER = 2;
-exports.HORIZONTAL_ALIGN_CENTER = HORIZONTAL_ALIGN_CENTER;
-var HORIZONTAL_ALIGN_RIGHT = 4;
-exports.HORIZONTAL_ALIGN_RIGHT = HORIZONTAL_ALIGN_RIGHT;
-var VERTICAL_ALIGN_TOP = 8;
-exports.VERTICAL_ALIGN_TOP = VERTICAL_ALIGN_TOP;
-var VERTICAL_ALIGN_MIDDLE = 16;
-exports.VERTICAL_ALIGN_MIDDLE = VERTICAL_ALIGN_MIDDLE;
-var VERTICAL_ALIGN_BOTTOM = 32; // blend modes
+export const VERTICAL_ALIGN_TOP = 8;
+export const VERTICAL_ALIGN_MIDDLE = 16;
+export const VERTICAL_ALIGN_BOTTOM = 32;
 
-exports.VERTICAL_ALIGN_BOTTOM = VERTICAL_ALIGN_BOTTOM;
-var BLEND_SOURCE_OVER = 'srcOver';
-exports.BLEND_SOURCE_OVER = BLEND_SOURCE_OVER;
-var BLEND_DESTINATION_OVER = 'dstOver';
-exports.BLEND_DESTINATION_OVER = BLEND_DESTINATION_OVER;
-var BLEND_MULTIPLY = 'multiply';
-exports.BLEND_MULTIPLY = BLEND_MULTIPLY;
-var BLEND_ADD = 'add';
-exports.BLEND_ADD = BLEND_ADD;
-var BLEND_SCREEN = 'screen';
-exports.BLEND_SCREEN = BLEND_SCREEN;
-var BLEND_OVERLAY = 'overlay';
-exports.BLEND_OVERLAY = BLEND_OVERLAY;
-var BLEND_DARKEN = 'darken';
-exports.BLEND_DARKEN = BLEND_DARKEN;
-var BLEND_LIGHTEN = 'lighten';
-exports.BLEND_LIGHTEN = BLEND_LIGHTEN;
-var BLEND_HARDLIGHT = 'hardLight';
-exports.BLEND_HARDLIGHT = BLEND_HARDLIGHT;
-var BLEND_DIFFERENCE = 'difference';
-exports.BLEND_DIFFERENCE = BLEND_DIFFERENCE;
-var BLEND_EXCLUSION = 'exclusion'; // Edge Handling
+// blend modes
+export const BLEND_SOURCE_OVER = 'srcOver';
+export const BLEND_DESTINATION_OVER = 'dstOver';
+export const BLEND_MULTIPLY = 'multiply';
+export const BLEND_ADD = 'add';
+export const BLEND_SCREEN = 'screen';
+export const BLEND_OVERLAY = 'overlay';
+export const BLEND_DARKEN = 'darken';
+export const BLEND_LIGHTEN = 'lighten';
+export const BLEND_HARDLIGHT = 'hardLight';
+export const BLEND_DIFFERENCE = 'difference';
+export const BLEND_EXCLUSION = 'exclusion';
 
-exports.BLEND_EXCLUSION = BLEND_EXCLUSION;
-var EDGE_EXTEND = 1;
-exports.EDGE_EXTEND = EDGE_EXTEND;
-var EDGE_WRAP = 2;
-exports.EDGE_WRAP = EDGE_WRAP;
-var EDGE_CROP = 3;
-exports.EDGE_CROP = EDGE_CROP;
-//# sourceMappingURL=constants.js.map
\ No newline at end of file
+// Edge Handling
+export const EDGE_EXTEND = 1;
+export const EDGE_WRAP = 2;
+export const EDGE_CROP = 3;
diff --git a/node_modules/@jimp/core/es/constants.js.map b/node_modules/@jimp/core/es/constants.js.map
deleted file mode 100644
index 31fc25e..0000000
--- a/node_modules/@jimp/core/es/constants.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"sources":["../src/constants.js"],"names":["AUTO","HORIZONTAL_ALIGN_LEFT","HORIZONTAL_ALIGN_CENTER","HORIZONTAL_ALIGN_RIGHT","VERTICAL_ALIGN_TOP","VERTICAL_ALIGN_MIDDLE","VERTICAL_ALIGN_BOTTOM","BLEND_SOURCE_OVER","BLEND_DESTINATION_OVER","BLEND_MULTIPLY","BLEND_ADD","BLEND_SCREEN","BLEND_OVERLAY","BLEND_DARKEN","BLEND_LIGHTEN","BLEND_HARDLIGHT","BLEND_DIFFERENCE","BLEND_EXCLUSION","EDGE_EXTEND","EDGE_WRAP","EDGE_CROP"],"mappings":";;;;;;AAAA;AACO,IAAMA,IAAI,GAAG,CAAC,CAAd,C,CAEP;;;AACO,IAAMC,qBAAqB,GAAG,CAA9B;;AACA,IAAMC,uBAAuB,GAAG,CAAhC;;AACA,IAAMC,sBAAsB,GAAG,CAA/B;;AAEA,IAAMC,kBAAkB,GAAG,CAA3B;;AACA,IAAMC,qBAAqB,GAAG,EAA9B;;AACA,IAAMC,qBAAqB,GAAG,EAA9B,C,CAEP;;;AACO,IAAMC,iBAAiB,GAAG,SAA1B;;AACA,IAAMC,sBAAsB,GAAG,SAA/B;;AACA,IAAMC,cAAc,GAAG,UAAvB;;AACA,IAAMC,SAAS,GAAG,KAAlB;;AACA,IAAMC,YAAY,GAAG,QAArB;;AACA,IAAMC,aAAa,GAAG,SAAtB;;AACA,IAAMC,YAAY,GAAG,QAArB;;AACA,IAAMC,aAAa,GAAG,SAAtB;;AACA,IAAMC,eAAe,GAAG,WAAxB;;AACA,IAAMC,gBAAgB,GAAG,YAAzB;;AACA,IAAMC,eAAe,GAAG,WAAxB,C,CAEP;;;AACO,IAAMC,WAAW,GAAG,CAApB;;AACA,IAAMC,SAAS,GAAG,CAAlB;;AACA,IAAMC,SAAS,GAAG,CAAlB","sourcesContent":["// used to auto resizing etc.\nexport const AUTO = -1;\n\n// Align modes for cover, contain, bit masks\nexport const HORIZONTAL_ALIGN_LEFT = 1;\nexport const HORIZONTAL_ALIGN_CENTER = 2;\nexport const HORIZONTAL_ALIGN_RIGHT = 4;\n\nexport const VERTICAL_ALIGN_TOP = 8;\nexport const VERTICAL_ALIGN_MIDDLE = 16;\nexport const VERTICAL_ALIGN_BOTTOM = 32;\n\n// blend modes\nexport const BLEND_SOURCE_OVER = 'srcOver';\nexport const BLEND_DESTINATION_OVER = 'dstOver';\nexport const BLEND_MULTIPLY = 'multiply';\nexport const BLEND_ADD = 'add';\nexport const BLEND_SCREEN = 'screen';\nexport const BLEND_OVERLAY = 'overlay';\nexport const BLEND_DARKEN = 'darken';\nexport const BLEND_LIGHTEN = 'lighten';\nexport const BLEND_HARDLIGHT = 'hardLight';\nexport const BLEND_DIFFERENCE = 'difference';\nexport const BLEND_EXCLUSION = 'exclusion';\n\n// Edge Handling\nexport const EDGE_EXTEND = 1;\nexport const EDGE_WRAP = 2;\nexport const EDGE_CROP = 3;\n"],"file":"constants.js"}
\ No newline at end of file
diff --git a/node_modules/@jimp/core/es/index.js b/node_modules/@jimp/core/es/index.js
index a656d75..e7edc26 100755
--- a/node_modules/@jimp/core/es/index.js
+++ b/node_modules/@jimp/core/es/index.js
@@ -1,107 +1,65 @@
-"use strict";
+import fs from 'fs';
+import Path from 'path';
+import EventEmitter from 'events';
 
-var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");
+import { isNodePattern, throwError, scan, scanIterator } from '@jimp/utils';
+import anyBase from 'any-base';
+import mkdirp from 'mkdirp';
+import pixelMatch from 'pixelmatch';
+import tinyColor from 'tinycolor2';
 
-var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
+import ImagePHash from './modules/phash';
+import request from './request';
 
-Object.defineProperty(exports, "__esModule", {
-  value: true
-});
-exports.addConstants = addConstants;
-exports.addJimpMethods = addJimpMethods;
-exports.jimpEvMethod = jimpEvMethod;
-exports.jimpEvChange = jimpEvChange;
-Object.defineProperty(exports, "addType", {
-  enumerable: true,
-  get: function get() {
-    return MIME.addType;
-  }
-});
-exports["default"] = void 0;
-
-var _construct2 = _interopRequireDefault(require("@babel/runtime/helpers/construct"));
-
-var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
-
-var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
-
-var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
-
-var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
-
-var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
-
-var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));
-
-var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
-
-var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
-
-var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
-
-var _fs = _interopRequireDefault(require("fs"));
-
-var _path = _interopRequireDefault(require("path"));
-
-var _events = _interopRequireDefault(require("events"));
-
-var _utils = require("@jimp/utils");
-
-var _anyBase = _interopRequireDefault(require("any-base"));
+import composite from './composite';
+import promisify from './utils/promisify';
+import * as MIME from './utils/mime';
+import { parseBitmap, getBuffer, getBufferAsync } from './utils/image-bitmap';
+import * as constants from './constants';
 
-var _mkdirp = _interopRequireDefault(require("mkdirp"));
+const alphabet =
+  '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_';
 
-var _pixelmatch = _interopRequireDefault(require("pixelmatch"));
-
-var _tinycolor = _interopRequireDefault(require("tinycolor2"));
-
-var _phash = _interopRequireDefault(require("./modules/phash"));
-
-var _request = _interopRequireDefault(require("./request"));
-
-var _composite = _interopRequireDefault(require("./composite"));
-
-var _promisify = _interopRequireDefault(require("./utils/promisify"));
-
-var MIME = _interopRequireWildcard(require("./utils/mime"));
-
-var _imageBitmap = require("./utils/image-bitmap");
-
-var constants = _interopRequireWildcard(require("./constants"));
-
-var alphabet = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_'; // an array storing the maximum string length of hashes at various bases
+// an array storing the maximum string length of hashes at various bases
 // 0 and 1 do not exist as possible hash lengths
+const maxHashLength = [NaN, NaN];
 
-var maxHashLength = [NaN, NaN];
-
-for (var i = 2; i < 65; i++) {
-  var maxHash = (0, _anyBase["default"])(_anyBase["default"].BIN, alphabet.slice(0, i))(new Array(64 + 1).join('1'));
+for (let i = 2; i < 65; i++) {
+  const maxHash = anyBase(anyBase.BIN, alphabet.slice(0, i))(
+    new Array(64 + 1).join('1')
+  );
   maxHashLength.push(maxHash.length);
-} // no operation
-
+}
 
-function noop() {} // error checking methods
+// no operation
+function noop() {}
 
+// error checking methods
 
 function isArrayBuffer(test) {
-  return Object.prototype.toString.call(test).toLowerCase().indexOf('arraybuffer') > -1;
-} // Prepare a Buffer object from the arrayBuffer. Necessary in the browser > node conversion,
-// But this function is not useful when running in node directly
-
+  return (
+    Object.prototype.toString
+      .call(test)
+      .toLowerCase()
+      .indexOf('arraybuffer') > -1
+  );
+}
 
+// Prepare a Buffer object from the arrayBuffer. Necessary in the browser > node conversion,
+// But this function is not useful when running in node directly
 function bufferFromArrayBuffer(arrayBuffer) {
-  var buffer = Buffer.alloc(arrayBuffer.byteLength);
-  var view = new Uint8Array(arrayBuffer);
+  const buffer = Buffer.alloc(arrayBuffer.byteLength);
+  const view = new Uint8Array(arrayBuffer);
 
-  for (var _i = 0; _i < buffer.length; ++_i) {
-    buffer[_i] = view[_i];
+  for (let i = 0; i < buffer.length; ++i) {
+    buffer[i] = view[i];
   }
 
   return buffer;
 }
 
 function loadFromURL(options, cb) {
-  (0, _request["default"])(options, function (err, response, data) {
+  request(options, (err, response, data) => {
     if (err) {
       return cb(err);
     }
@@ -111,27 +69,47 @@ function loadFromURL(options, cb) {
       return loadFromURL(options, cb);
     }
 
-    if ((0, _typeof2["default"])(data) === 'object' && Buffer.isBuffer(data)) {
+    if (typeof data === 'object' && Buffer.isBuffer(data)) {
       return cb(null, data);
     }
 
-    var msg = 'Could not load Buffer from <' + options.url + '> ' + '(HTTP: ' + response.statusCode + ')';
+    const msg =
+      'Could not load Buffer from <' +
+      options.url +
+      '> ' +
+      '(HTTP: ' +
+      response.statusCode +
+      ')';
+
     return new Error(msg);
   });
 }
 
 function loadBufferFromPath(src, cb) {
-  if (_fs["default"] && typeof _fs["default"].readFile === 'function' && !src.match(/^(http|ftp)s?:\/\/./)) {
-    _fs["default"].readFile(src, cb);
+  if (
+    fs &&
+    typeof fs.readFile === 'function' &&
+    !src.match(/^(http|ftp)s?:\/\/./)
+  ) {
+    fs.readFile(src, cb);
   } else {
-    loadFromURL({
-      url: src
-    }, cb);
+    loadFromURL({ url: src }, cb);
   }
 }
 
 function isRawRGBAData(obj) {
-  return obj && (0, _typeof2["default"])(obj) === 'object' && typeof obj.width === 'number' && typeof obj.height === 'number' && (Buffer.isBuffer(obj.data) || obj.data instanceof Uint8Array || typeof Uint8ClampedArray === 'function' && obj.data instanceof Uint8ClampedArray) && (obj.data.length === obj.width * obj.height * 4 || obj.data.length === obj.width * obj.height * 3);
+  return (
+    obj &&
+    typeof obj === 'object' &&
+    typeof obj.width === 'number' &&
+    typeof obj.height === 'number' &&
+    (Buffer.isBuffer(obj.data) ||
+      obj.data instanceof Uint8Array ||
+      (typeof Uint8ClampedArray === 'function' &&
+        obj.data instanceof Uint8ClampedArray)) &&
+    (obj.data.length === obj.width * obj.height * 4 ||
+      obj.data.length === obj.width * obj.height * 3)
+  );
 }
 
 function makeRGBABufferFromRGB(buffer) {
@@ -139,13 +117,13 @@ function makeRGBABufferFromRGB(buffer) {
     throw new Error('Buffer length is incorrect');
   }
 
-  var rgbaBuffer = Buffer.allocUnsafe(buffer.length / 3 * 4);
-  var j = 0;
+  const rgbaBuffer = Buffer.allocUnsafe((buffer.length / 3) * 4);
+  let j = 0;
 
-  for (var _i2 = 0; _i2 < buffer.length; _i2++) {
-    rgbaBuffer[j] = buffer[_i2];
+  for (let i = 0; i < buffer.length; i++) {
+    rgbaBuffer[j] = buffer[i];
 
-    if ((_i2 + 1) % 3 === 0) {
+    if ((i + 1) % 3 === 0) {
       rgbaBuffer[++j] = 255;
     }
 
@@ -155,11 +133,12 @@ function makeRGBABufferFromRGB(buffer) {
   return rgbaBuffer;
 }
 
-var emptyBitmap = {
+const emptyBitmap = {
   data: null,
   width: null,
   height: null
 };
+
 /**
  * Jimp constructor (from a file)
  * @param path a path to the image
@@ -199,61 +178,41 @@ var emptyBitmap = {
  * @param {function(Error, Jimp)} cb (optional) a function to call when the image is parsed to a bitmap
  */
 
-var Jimp =
-/*#__PURE__*/
-function (_EventEmitter) {
-  (0, _inherits2["default"])(Jimp, _EventEmitter);
-
+class Jimp extends EventEmitter {
   // An object representing a bitmap in memory, comprising:
   //  - data: a buffer of the bitmap data
   //  - width: the width of the image in pixels
   //  - height: the height of the image in pixels
+  bitmap = emptyBitmap;
+
   // Default colour to use for new pixels
+  _background = 0x00000000;
+
   // Default MIME is PNG
+  _originalMime = Jimp.MIME_PNG;
+
   // Exif data for the image
+  _exif = null;
+
   // Whether Transparency supporting formats will be exported as RGB or RGBA
-  function Jimp() {
-    var _this;
+  _rgba = true;
 
-    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
-      args[_key] = arguments[_key];
-    }
+  constructor(...args) {
+    super();
 
-    (0, _classCallCheck2["default"])(this, Jimp);
-    _this = (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(Jimp).call(this));
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "bitmap", emptyBitmap);
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_background", 0x00000000);
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_originalMime", Jimp.MIME_PNG);
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_exif", null);
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_rgba", true);
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "writeAsync", function (path) {
-      return (0, _promisify["default"])(_this.write, (0, _assertThisInitialized2["default"])(_this), path);
-    });
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "getBase64Async", function (mime) {
-      return (0, _promisify["default"])(_this.getBase64, (0, _assertThisInitialized2["default"])(_this), mime);
-    });
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "getBuffer", _imageBitmap.getBuffer);
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "getBufferAsync", _imageBitmap.getBufferAsync);
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "getPixelColour", _this.getPixelColor);
-    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "setPixelColour", _this.setPixelColor);
-    var jimpInstance = (0, _assertThisInitialized2["default"])(_this);
-    var cb = noop;
+    const jimpInstance = this;
+    let cb = noop;
 
     if (isArrayBuffer(args[0])) {
       args[0] = bufferFromArrayBuffer(args[0]);
     }
 
-    function finish() {
-      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
-        args[_key2] = arguments[_key2];
-      }
-
-      var err = args[0];
-      var evData = err || {};
+    function finish(...args) {
+      const [err] = args;
+      const evData = err || {};
       evData.methodName = 'constructor';
-      setTimeout(function () {
-        var _cb;
 
+      setTimeout(() => {
         // run on next tick.
         if (err && cb === noop) {
           jimpInstance.emitError('constructor', err);
@@ -261,24 +220,28 @@ function (_EventEmitter) {
           jimpInstance.emitMulti('constructor', 'initialized');
         }
 
-        (_cb = cb).call.apply(_cb, [jimpInstance].concat(args));
+        cb.call(jimpInstance, ...args);
       }, 1);
     }
 
-    if (typeof args[0] === 'number' && typeof args[1] === 'number' || parseInt(args[0], 10) && parseInt(args[1], 10)) {
+    if (
+      (typeof args[0] === 'number' && typeof args[1] === 'number') ||
+      (parseInt(args[0], 10) && parseInt(args[1], 10))
+    ) {
       // create a new image
-      var w = parseInt(args[0], 10);
-      var h = parseInt(args[1], 10);
-      cb = args[2]; // with a hex color
+      const w = parseInt(args[0], 10);
+      const h = parseInt(args[1], 10);
+      cb = args[2];
 
+      // with a hex color
       if (typeof args[2] === 'number') {
-        _this._background = args[2];
+        this._background = args[2];
         cb = args[3];
-      } // with a css color
-
+      }
 
+      // with a css color
       if (typeof args[2] === 'string') {
-        _this._background = Jimp.cssColorToHex(args[2]);
+        this._background = Jimp.cssColorToHex(args[2]);
         cb = args[3];
       }
 
@@ -287,37 +250,37 @@ function (_EventEmitter) {
       }
 
       if (typeof cb !== 'function') {
-        return (0, _possibleConstructorReturn2["default"])(_this, _utils.throwError.call((0, _assertThisInitialized2["default"])(_this), 'cb must be a function', finish));
+        return throwError.call(this, 'cb must be a function', finish);
       }
 
-      _this.bitmap = {
+      this.bitmap = {
         data: Buffer.alloc(w * h * 4),
         width: w,
         height: h
       };
 
-      for (var _i3 = 0; _i3 < _this.bitmap.data.length; _i3 += 4) {
-        _this.bitmap.data.writeUInt32BE(_this._background, _i3);
+      for (let i = 0; i < this.bitmap.data.length; i += 4) {
+        this.bitmap.data.writeUInt32BE(this._background, i);
       }
 
-      finish(null, (0, _assertThisInitialized2["default"])(_this));
-    } else if ((0, _typeof2["default"])(args[0]) === 'object' && args[0].url) {
+      finish(null, this);
+    } else if (typeof args[0] === 'object' && args[0].url) {
       cb = args[1] || noop;
 
       if (typeof cb !== 'function') {
-        return (0, _possibleConstructorReturn2["default"])(_this, _utils.throwError.call((0, _assertThisInitialized2["default"])(_this), 'cb must be a function', finish));
+        return throwError.call(this, 'cb must be a function', finish);
       }
 
-      loadFromURL(args[0], function (err, data) {
+      loadFromURL(args[0], (err, data) => {
         if (err) {
-          return _utils.throwError.call((0, _assertThisInitialized2["default"])(_this), err, finish);
+          return throwError.call(this, err, finish);
         }
 
-        _this.parseBitmap(data, args[0].url, finish);
+        this.parseBitmap(data, args[0].url, finish);
       });
     } else if (args[0] instanceof Jimp) {
       // clone an existing Jimp
-      var original = args[0];
+      const [original] = args;
       cb = args[1];
 
       if (typeof cb === 'undefined') {
@@ -325,36 +288,44 @@ function (_EventEmitter) {
       }
 
       if (typeof cb !== 'function') {
-        return (0, _possibleConstructorReturn2["default"])(_this, _utils.throwError.call((0, _assertThisInitialized2["default"])(_this), 'cb must be a function', finish));
+        return throwError.call(this, 'cb must be a function', finish);
       }
 
-      _this.bitmap = {
+      this.bitmap = {
         data: Buffer.from(original.bitmap.data),
         width: original.bitmap.width,
         height: original.bitmap.height
       };
-      _this._quality = original._quality;
-      _this._deflateLevel = original._deflateLevel;
-      _this._deflateStrategy = original._deflateStrategy;
-      _this._filterType = original._filterType;
-      _this._rgba = original._rgba;
-      _this._background = original._background;
-      _this._originalMime = original._originalMime;
-      finish(null, (0, _assertThisInitialized2["default"])(_this));
+
+      this._quality = original._quality;
+      this._deflateLevel = original._deflateLevel;
+      this._deflateStrategy = original._deflateStrategy;
+      this._filterType = original._filterType;
+      this._rgba = original._rgba;
+      this._background = original._background;
+      this._originalMime = original._originalMime;
+
+      finish(null, this);
     } else if (isRawRGBAData(args[0])) {
-      var imageData = args[0];
+      const [imageData] = args;
       cb = args[1] || noop;
-      var isRGBA = imageData.width * imageData.height * 4 === imageData.data.length;
-      var buffer = isRGBA ? Buffer.from(imageData.data) : makeRGBABufferFromRGB(imageData.data);
-      _this.bitmap = {
+
+      const isRGBA =
+        imageData.width * imageData.height * 4 === imageData.data.length;
+      const buffer = isRGBA
+        ? Buffer.from(imageData.data)
+        : makeRGBABufferFromRGB(imageData.data);
+
+      this.bitmap = {
         data: buffer,
         width: imageData.width,
         height: imageData.height
       };
-      finish(null, (0, _assertThisInitialized2["default"])(_this));
+
+      finish(null, this);
     } else if (typeof args[0] === 'string') {
       // read from a path
-      var path = args[0];
+      const path = args[0];
       cb = args[1];
 
       if (typeof cb === 'undefined') {
@@ -362,26 +333,26 @@ function (_EventEmitter) {
       }
 
       if (typeof cb !== 'function') {
-        return (0, _possibleConstructorReturn2["default"])(_this, _utils.throwError.call((0, _assertThisInitialized2["default"])(_this), 'cb must be a function', finish));
+        return throwError.call(this, 'cb must be a function', finish);
       }
 
-      loadBufferFromPath(path, function (err, data) {
+      loadBufferFromPath(path, (err, data) => {
         if (err) {
-          return _utils.throwError.call((0, _assertThisInitialized2["default"])(_this), err, finish);
+          return throwError.call(this, err, finish);
         }
 
-        _this.parseBitmap(data, path, finish);
+        this.parseBitmap(data, path, finish);
       });
-    } else if ((0, _typeof2["default"])(args[0]) === 'object' && Buffer.isBuffer(args[0])) {
+    } else if (typeof args[0] === 'object' && Buffer.isBuffer(args[0])) {
       // read from a buffer
-      var data = args[0];
+      const data = args[0];
       cb = args[1];
 
       if (typeof cb !== 'function') {
-        return (0, _possibleConstructorReturn2["default"])(_this, _utils.throwError.call((0, _assertThisInitialized2["default"])(_this), 'cb must be a function', finish));
+        return throwError.call(this, 'cb must be a function', finish);
       }
 
-      _this.parseBitmap(data, null, finish);
+      this.parseBitmap(data, null, finish);
     } else {
       // Allow client libs to add new ways to build a Jimp object.
       // Extra constructors must be added by `Jimp.appendConstructorOption()`
@@ -396,25 +367,27 @@ function (_EventEmitter) {
         }
       }
 
-      var extraConstructor = Jimp.__extraConstructors.find(function (c) {
-        return c.test.apply(c, args);
-      });
+      const extraConstructor = Jimp.__extraConstructors.find(c =>
+        c.test(...args)
+      );
 
       if (extraConstructor) {
-        new Promise(function (resolve, reject) {
-          var _extraConstructor$run;
-
-          return (_extraConstructor$run = extraConstructor.run).call.apply(_extraConstructor$run, [(0, _assertThisInitialized2["default"])(_this), resolve, reject].concat(args));
-        }).then(function () {
-          return finish(null, (0, _assertThisInitialized2["default"])(_this));
-        })["catch"](finish);
+        new Promise((resolve, reject) =>
+          extraConstructor.run.call(this, resolve, reject, ...args)
+        )
+          .then(() => finish(null, this))
+          .catch(finish);
       } else {
-        return (0, _possibleConstructorReturn2["default"])(_this, _utils.throwError.call((0, _assertThisInitialized2["default"])(_this), 'No matching constructor overloading was found. ' + 'Please see the docs for how to call the Jimp constructor.', finish));
+        return throwError.call(
+          this,
+          'No matching constructor overloading was found. ' +
+            'Please see the docs for how to call the Jimp constructor.',
+          finish
+        );
       }
     }
-
-    return _this;
   }
+
   /**
    * Parse a bitmap with the loaded image types.
    *
@@ -423,513 +396,490 @@ function (_EventEmitter) {
    * @param {function(Error, Jimp)} finish (optional) a callback for when complete
    * @memberof Jimp
    */
+  parseBitmap(data, path, finish) {
+    parseBitmap.call(this, data, null, finish);
+  }
 
+  /**
+   * Sets the type of the image (RGB or RGBA) when saving in a format that supports transparency (default is RGBA)
+   * @param {boolean} bool A Boolean, true to use RGBA or false to use RGB
+   * @param {function(Error, Jimp)} cb (optional) a callback for when complete
+   * @returns {Jimp} this for chaining of methods
+   */
+  rgba(bool, cb) {
+    if (typeof bool !== 'boolean') {
+      return throwError.call(
+        this,
+        'bool must be a boolean, true for RGBA or false for RGB',
+        cb
+      );
+    }
 
-  (0, _createClass2["default"])(Jimp, [{
-    key: "parseBitmap",
-    value: function parseBitmap(data, path, finish) {
-      _imageBitmap.parseBitmap.call(this, data, null, finish);
+    this._rgba = bool;
+
+    if (isNodePattern(cb)) {
+      cb.call(this, null, this);
     }
-    /**
-     * Sets the type of the image (RGB or RGBA) when saving in a format that supports transparency (default is RGBA)
-     * @param {boolean} bool A Boolean, true to use RGBA or false to use RGB
-     * @param {function(Error, Jimp)} cb (optional) a callback for when complete
-     * @returns {Jimp} this for chaining of methods
-     */
-
-  }, {
-    key: "rgba",
-    value: function rgba(bool, cb) {
-      if (typeof bool !== 'boolean') {
-        return _utils.throwError.call(this, 'bool must be a boolean, true for RGBA or false for RGB', cb);
-      }
 
-      this._rgba = bool;
+    return this;
+  }
 
-      if ((0, _utils.isNodePattern)(cb)) {
-        cb.call(this, null, this);
-      }
+  /**
+   * Emit for multiple listeners
+   * @param {string} methodName name of the method to emit an error for
+   * @param {string} eventName name of the eventName to emit an error for
+   * @param {object} data to emit
+   */
+  emitMulti(methodName, eventName, data = {}) {
+    data = Object.assign(data, { methodName, eventName });
+    this.emit('any', data);
 
-      return this;
+    if (methodName) {
+      this.emit(methodName, data);
     }
-    /**
-     * Emit for multiple listeners
-     * @param {string} methodName name of the method to emit an error for
-     * @param {string} eventName name of the eventName to emit an error for
-     * @param {object} data to emit
-     */
-
-  }, {
-    key: "emitMulti",
-    value: function emitMulti(methodName, eventName) {
-      var data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
-      data = Object.assign(data, {
-        methodName: methodName,
-        eventName: eventName
-      });
-      this.emit('any', data);
 
-      if (methodName) {
-        this.emit(methodName, data);
-      }
+    this.emit(eventName, data);
+  }
 
-      this.emit(eventName, data);
-    }
-  }, {
-    key: "emitError",
-    value: function emitError(methodName, err) {
-      this.emitMulti(methodName, 'error', err);
-    }
-    /**
-     * Get the current height of the image
-     * @return {number} height of the image
-     */
-
-  }, {
-    key: "getHeight",
-    value: function getHeight() {
-      return this.bitmap.height;
-    }
-    /**
-     * Get the current width of the image
-     * @return {number} width of the image
-     */
-
-  }, {
-    key: "getWidth",
-    value: function getWidth() {
-      return this.bitmap.width;
-    }
-    /**
-     * Nicely format Jimp object when sent to the console e.g. console.log(image)
-     * @returns {string} pretty printed
-     */
-
-  }, {
-    key: "inspect",
-    value: function inspect() {
-      return '<Jimp ' + (this.bitmap === emptyBitmap ? 'pending...' : this.bitmap.width + 'x' + this.bitmap.height) + '>';
-    }
-    /**
-     * Nicely format Jimp object when converted to a string
-     * @returns {string} pretty printed
-     */
-
-  }, {
-    key: "toString",
-    value: function toString() {
-      return '[object Jimp]';
-    }
-    /**
-     * Returns the original MIME of the image (default: "image/png")
-     * @returns {string} the MIME
-     */
-
-  }, {
-    key: "getMIME",
-    value: function getMIME() {
-      var mime = this._originalMime || Jimp.MIME_PNG;
-      return mime;
-    }
-    /**
-     * Returns the appropriate file extension for the original MIME of the image (default: "png")
-     * @returns {string} the file extension
-     */
-
-  }, {
-    key: "getExtension",
-    value: function getExtension() {
-      var mime = this.getMIME();
-      return MIME.getExtension(mime);
+  emitError(methodName, err) {
+    this.emitMulti(methodName, 'error', err);
+  }
+
+  /**
+   * Get the current height of the image
+   * @return {number} height of the image
+   */
+  getHeight() {
+    return this.bitmap.height;
+  }
+
+  /**
+   * Get the current width of the image
+   * @return {number} width of the image
+   */
+  getWidth() {
+    return this.bitmap.width;
+  }
+
+  /**
+   * Nicely format Jimp object when sent to the console e.g. console.log(image)
+   * @returns {string} pretty printed
+   */
+  inspect() {
+    return (
+      '<Jimp ' +
+      (this.bitmap === emptyBitmap
+        ? 'pending...'
+        : this.bitmap.width + 'x' + this.bitmap.height) +
+      '>'
+    );
+  }
+
+  /**
+   * Nicely format Jimp object when converted to a string
+   * @returns {string} pretty printed
+   */
+  toString() {
+    return '[object Jimp]';
+  }
+
+  /**
+   * Returns the original MIME of the image (default: "image/png")
+   * @returns {string} the MIME
+   */
+  getMIME() {
+    const mime = this._originalMime || Jimp.MIME_PNG;
+
+    return mime;
+  }
+
+  /**
+   * Returns the appropriate file extension for the original MIME of the image (default: "png")
+   * @returns {string} the file extension
+   */
+  getExtension() {
+    const mime = this.getMIME();
+
+    return MIME.getExtension(mime);
+  }
+
+  /**
+   * Writes the image to a file
+   * @param {string} path a path to the destination file
+   * @param {function(Error, Jimp)} cb (optional) a function to call when the image is saved to disk
+   * @returns {Jimp} this for chaining of methods
+   */
+  write(path, cb) {
+    if (!fs || !fs.createWriteStream) {
+      throw new Error(
+        'Cant access the filesystem. You can use the getBase64 method.'
+      );
     }
-    /**
-     * Writes the image to a file
-     * @param {string} path a path to the destination file
-     * @param {function(Error, Jimp)} cb (optional) a function to call when the image is saved to disk
-     * @returns {Jimp} this for chaining of methods
-     */
-
-  }, {
-    key: "write",
-    value: function write(path, cb) {
-      var _this2 = this;
-
-      if (!_fs["default"] || !_fs["default"].createWriteStream) {
-        throw new Error('Cant access the filesystem. You can use the getBase64 method.');
-      }
 
-      if (typeof path !== 'string') {
-        return _utils.throwError.call(this, 'path must be a string', cb);
-      }
+    if (typeof path !== 'string') {
+      return throwError.call(this, 'path must be a string', cb);
+    }
 
-      if (typeof cb === 'undefined') {
-        cb = noop;
-      }
+    if (typeof cb === 'undefined') {
+      cb = noop;
+    }
 
-      if (typeof cb !== 'function') {
-        return _utils.throwError.call(this, 'cb must be a function', cb);
-      }
+    if (typeof cb !== 'function') {
+      return throwError.call(this, 'cb must be a function', cb);
+    }
 
-      var mime = MIME.getType(path) || this.getMIME();
+    const mime = MIME.getType(path) || this.getMIME();
+    const pathObj = Path.parse(path);
 
-      var pathObj = _path["default"].parse(path);
+    if (pathObj.dir) {
+      mkdirp.sync(pathObj.dir);
+    }
 
-      if (pathObj.dir) {
-        _mkdirp["default"].sync(pathObj.dir);
+    this.getBuffer(mime, (err, buffer) => {
+      if (err) {
+        return throwError.call(this, err, cb);
       }
 
-      this.getBuffer(mime, function (err, buffer) {
-        if (err) {
-          return _utils.throwError.call(_this2, err, cb);
-        }
-
-        var stream = _fs["default"].createWriteStream(path);
+      const stream = fs.createWriteStream(path);
 
-        stream.on('open', function () {
+      stream
+        .on('open', () => {
           stream.write(buffer);
           stream.end();
-        }).on('error', function (err) {
-          return _utils.throwError.call(_this2, err, cb);
-        });
-        stream.on('finish', function () {
-          cb.call(_this2, null, _this2);
+        })
+        .on('error', err => {
+          return throwError.call(this, err, cb);
         });
+      stream.on('finish', () => {
+        cb.call(this, null, this);
       });
-      return this;
-    }
-  }, {
-    key: "getBase64",
-
-    /**
-     * Converts the image to a base 64 string
-     * @param {string} mime the mime type of the image data to be created
-     * @param {function(Error, Jimp)} cb a Node-style function to call with the buffer as the second argument
-     * @returns {Jimp} this for chaining of methods
-     */
-    value: function getBase64(mime, cb) {
-      if (mime === Jimp.AUTO) {
-        // allow auto MIME detection
-        mime = this.getMIME();
-      }
+    });
 
-      if (typeof mime !== 'string') {
-        return _utils.throwError.call(this, 'mime must be a string', cb);
-      }
+    return this;
+  }
 
-      if (typeof cb !== 'function') {
-        return _utils.throwError.call(this, 'cb must be a function', cb);
-      }
+  writeAsync = path => promisify(this.write, this, path);
 
-      this.getBuffer(mime, function (err, data) {
-        if (err) {
-          return _utils.throwError.call(this, err, cb);
-        }
+  /**
+   * Converts the image to a base 64 string
+   * @param {string} mime the mime type of the image data to be created
+   * @param {function(Error, Jimp)} cb a Node-style function to call with the buffer as the second argument
+   * @returns {Jimp} this for chaining of methods
+   */
+  getBase64(mime, cb) {
+    if (mime === Jimp.AUTO) {
+      // allow auto MIME detection
+      mime = this.getMIME();
+    }
 
-        var src = 'data:' + mime + ';base64,' + data.toString('base64');
-        cb.call(this, null, src);
-      });
-      return this;
+    if (typeof mime !== 'string') {
+      return throwError.call(this, 'mime must be a string', cb);
     }
-  }, {
-    key: "hash",
-
-    /**
-     * Generates a perceptual hash of the image <https://en.wikipedia.org/wiki/Perceptual_hashing>. And pads the string. Can configure base.
-     * @param {number} base (optional) a number between 2 and 64 representing the base for the hash (e.g. 2 is binary, 10 is decimal, 16 is hex, 64 is base 64). Defaults to 64.
-     * @param {function(Error, Jimp)} cb (optional) a callback for when complete
-     * @returns {string} a string representing the hash
-     */
-    value: function hash(base, cb) {
-      base = base || 64;
-
-      if (typeof base === 'function') {
-        cb = base;
-        base = 64;
-      }
 
-      if (typeof base !== 'number') {
-        return _utils.throwError.call(this, 'base must be a number', cb);
-      }
+    if (typeof cb !== 'function') {
+      return throwError.call(this, 'cb must be a function', cb);
+    }
 
-      if (base < 2 || base > 64) {
-        return _utils.throwError.call(this, 'base must be a number between 2 and 64', cb);
+    this.getBuffer(mime, function(err, data) {
+      if (err) {
+        return throwError.call(this, err, cb);
       }
 
-      var hash = this.pHash();
-      hash = (0, _anyBase["default"])(_anyBase["default"].BIN, alphabet.slice(0, base))(hash);
+      const src = 'data:' + mime + ';base64,' + data.toString('base64');
+      cb.call(this, null, src);
+    });
 
-      while (hash.length < maxHashLength[base]) {
-        hash = '0' + hash; // pad out with leading zeros
-      }
+    return this;
+  }
 
-      if ((0, _utils.isNodePattern)(cb)) {
-        cb.call(this, null, hash);
-      }
+  getBase64Async = mime => promisify(this.getBase64, this, mime);
 
-      return hash;
+  /**
+   * Generates a perceptual hash of the image <https://en.wikipedia.org/wiki/Perceptual_hashing>. And pads the string. Can configure base.
+   * @param {number} base (optional) a number between 2 and 64 representing the base for the hash (e.g. 2 is binary, 10 is decimal, 16 is hex, 64 is base 64). Defaults to 64.
+   * @param {function(Error, Jimp)} cb (optional) a callback for when complete
+   * @returns {string} a string representing the hash
+   */
+  hash(base, cb) {
+    base = base || 64;
+
+    if (typeof base === 'function') {
+      cb = base;
+      base = 64;
     }
-    /**
-     * Calculates the perceptual hash
-     * @returns {number} the perceptual hash
-     */
-
-  }, {
-    key: "pHash",
-    value: function pHash() {
-      var pHash = new _phash["default"]();
-      return pHash.getHash(this);
+
+    if (typeof base !== 'number') {
+      return throwError.call(this, 'base must be a number', cb);
     }
-    /**
-     * Calculates the hamming distance of the current image and a hash based on their perceptual hash
-     * @param {hash} compareHash hash to compare to
-     * @returns {number} a number ranging from 0 to 1, 0 means they are believed to be identical
-     */
-
-  }, {
-    key: "distanceFromHash",
-    value: function distanceFromHash(compareHash) {
-      var pHash = new _phash["default"]();
-      var currentHash = pHash.getHash(this);
-      return pHash.distance(currentHash, compareHash);
+
+    if (base < 2 || base > 64) {
+      return throwError.call(
+        this,
+        'base must be a number between 2 and 64',
+        cb
+      );
     }
-    /**
-     * Converts the image to a buffer
-     * @param {string} mime the mime type of the image buffer to be created
-     * @param {function(Error, Jimp)} cb a Node-style function to call with the buffer as the second argument
-     * @returns {Jimp} this for chaining of methods
-     */
-
-  }, {
-    key: "getPixelIndex",
-
-    /**
-     * Returns the offset of a pixel in the bitmap buffer
-     * @param {number} x the x coordinate
-     * @param {number} y the y coordinate
-     * @param {string} edgeHandling (optional) define how to sum pixels from outside the border
-     * @param {number} cb (optional) a callback for when complete
-     * @returns {number} the index of the pixel or -1 if not found
-     */
-    value: function getPixelIndex(x, y, edgeHandling, cb) {
-      var xi;
-      var yi;
-
-      if (typeof edgeHandling === 'function' && typeof cb === 'undefined') {
-        cb = edgeHandling;
-        edgeHandling = null;
-      }
 
-      if (!edgeHandling) {
-        edgeHandling = Jimp.EDGE_EXTEND;
-      }
+    let hash = this.pHash();
+    hash = anyBase(anyBase.BIN, alphabet.slice(0, base))(hash);
 
-      if (typeof x !== 'number' || typeof y !== 'number') {
-        return _utils.throwError.call(this, 'x and y must be numbers', cb);
-      } // round input
+    while (hash.length < maxHashLength[base]) {
+      hash = '0' + hash; // pad out with leading zeros
+    }
 
+    if (isNodePattern(cb)) {
+      cb.call(this, null, hash);
+    }
 
-      x = Math.round(x);
-      y = Math.round(y);
-      xi = x;
-      yi = y;
+    return hash;
+  }
 
-      if (edgeHandling === Jimp.EDGE_EXTEND) {
-        if (x < 0) xi = 0;
-        if (x >= this.bitmap.width) xi = this.bitmap.width - 1;
-        if (y < 0) yi = 0;
-        if (y >= this.bitmap.height) yi = this.bitmap.height - 1;
-      }
+  /**
+   * Calculates the perceptual hash
+   * @returns {number} the perceptual hash
+   */
+  pHash() {
+    const pHash = new ImagePHash();
+    return pHash.getHash(this);
+  }
 
-      if (edgeHandling === Jimp.EDGE_WRAP) {
-        if (x < 0) {
-          xi = this.bitmap.width + x;
-        }
+  /**
+   * Calculates the hamming distance of the current image and a hash based on their perceptual hash
+   * @param {hash} compareHash hash to compare to
+   * @returns {number} a number ranging from 0 to 1, 0 means they are believed to be identical
+   */
+  distanceFromHash(compareHash) {
+    const pHash = new ImagePHash();
+    const currentHash = pHash.getHash(this);
 
-        if (x >= this.bitmap.width) {
-          xi = x % this.bitmap.width;
-        }
+    return pHash.distance(currentHash, compareHash);
+  }
 
-        if (y < 0) {
-          xi = this.bitmap.height + y;
-        }
+  /**
+   * Converts the image to a buffer
+   * @param {string} mime the mime type of the image buffer to be created
+   * @param {function(Error, Jimp)} cb a Node-style function to call with the buffer as the second argument
+   * @returns {Jimp} this for chaining of methods
+   */
+  getBuffer = getBuffer;
 
-        if (y >= this.bitmap.height) {
-          yi = y % this.bitmap.height;
-        }
-      }
+  getBufferAsync = getBufferAsync;
+
+  /**
+   * Returns the offset of a pixel in the bitmap buffer
+   * @param {number} x the x coordinate
+   * @param {number} y the y coordinate
+   * @param {string} edgeHandling (optional) define how to sum pixels from outside the border
+   * @param {number} cb (optional) a callback for when complete
+   * @returns {number} the index of the pixel or -1 if not found
+   */
+  getPixelIndex(x, y, edgeHandling, cb) {
+    let xi;
+    let yi;
+
+    if (typeof edgeHandling === 'function' && typeof cb === 'undefined') {
+      cb = edgeHandling;
+      edgeHandling = null;
+    }
+
+    if (!edgeHandling) {
+      edgeHandling = Jimp.EDGE_EXTEND;
+    }
+
+    if (typeof x !== 'number' || typeof y !== 'number') {
+      return throwError.call(this, 'x and y must be numbers', cb);
+    }
 
-      var i = this.bitmap.width * yi + xi << 2; // if out of bounds index is -1
+    // round input
+    x = Math.round(x);
+    y = Math.round(y);
+    xi = x;
+    yi = y;
+
+    if (edgeHandling === Jimp.EDGE_EXTEND) {
+      if (x < 0) xi = 0;
+      if (x >= this.bitmap.width) xi = this.bitmap.width - 1;
+      if (y < 0) yi = 0;
+      if (y >= this.bitmap.height) yi = this.bitmap.height - 1;
+    }
 
-      if (xi < 0 || xi >= this.bitmap.width) {
-        i = -1;
+    if (edgeHandling === Jimp.EDGE_WRAP) {
+      if (x < 0) {
+        xi = this.bitmap.width + x;
       }
 
-      if (yi < 0 || yi >= this.bitmap.height) {
-        i = -1;
+      if (x >= this.bitmap.width) {
+        xi = x % this.bitmap.width;
       }
 
-      if ((0, _utils.isNodePattern)(cb)) {
-        cb.call(this, null, i);
+      if (y < 0) {
+        xi = this.bitmap.height + y;
       }
 
-      return i;
-    }
-    /**
-     * Returns the hex colour value of a pixel
-     * @param {number} x the x coordinate
-     * @param {number} y the y coordinate
-     * @param {function(Error, Jimp)} cb (optional) a callback for when complete
-     * @returns {number} the color of the pixel
-     */
-
-  }, {
-    key: "getPixelColor",
-    value: function getPixelColor(x, y, cb) {
-      if (typeof x !== 'number' || typeof y !== 'number') return _utils.throwError.call(this, 'x and y must be numbers', cb); // round input
-
-      x = Math.round(x);
-      y = Math.round(y);
-      var idx = this.getPixelIndex(x, y);
-      var hex = this.bitmap.data.readUInt32BE(idx);
-
-      if ((0, _utils.isNodePattern)(cb)) {
-        cb.call(this, null, hex);
+      if (y >= this.bitmap.height) {
+        yi = y % this.bitmap.height;
       }
+    }
+
+    let i = (this.bitmap.width * yi + xi) << 2;
 
-      return hex;
+    // if out of bounds index is -1
+    if (xi < 0 || xi >= this.bitmap.width) {
+      i = -1;
     }
-  }, {
-    key: "setPixelColor",
-
-    /**
-     * Returns the hex colour value of a pixel
-     * @param {number} hex color to set
-     * @param {number} x the x coordinate
-     * @param {number} y the y coordinate
-     * @param {function(Error, Jimp)} cb (optional) a callback for when complete
-     * @returns {number} the index of the pixel or -1 if not found
-     */
-    value: function setPixelColor(hex, x, y, cb) {
-      if (typeof hex !== 'number' || typeof x !== 'number' || typeof y !== 'number') return _utils.throwError.call(this, 'hex, x and y must be numbers', cb); // round input
-
-      x = Math.round(x);
-      y = Math.round(y);
-      var idx = this.getPixelIndex(x, y);
-      this.bitmap.data.writeUInt32BE(hex, idx);
-
-      if ((0, _utils.isNodePattern)(cb)) {
-        cb.call(this, null, this);
-      }
 
-      return this;
+    if (yi < 0 || yi >= this.bitmap.height) {
+      i = -1;
     }
-  }, {
-    key: "hasAlpha",
-
-    /**
-     * Determine if the image contains opaque pixels.
-     * @return {boolean} hasAlpha whether the image contains opaque pixels
-     */
-    value: function hasAlpha() {
-      for (var yIndex = 0; yIndex < this.bitmap.height; yIndex++) {
-        for (var xIndex = 0; xIndex < this.bitmap.width; xIndex++) {
-          var idx = this.bitmap.width * yIndex + xIndex << 2;
-          var alpha = this.bitmap.data[idx + 3];
-
-          if (alpha !== 0xff) {
-            return true;
-          }
-        }
-      }
 
-      return false;
+    if (isNodePattern(cb)) {
+      cb.call(this, null, i);
     }
-    /**
-     * Iterate scan through a region of the bitmap
-     * @param {number} x the x coordinate to begin the scan at
-     * @param {number} y the y coordinate to begin the scan at
-     * @param w the width of the scan region
-     * @param h the height of the scan region
-     * @returns {IterableIterator<{x: number, y: number, idx: number, image: Jimp}>}
-     */
-
-  }, {
-    key: "scanIterator",
-    value: function scanIterator(x, y, w, h) {
-      if (typeof x !== 'number' || typeof y !== 'number') {
-        return _utils.throwError.call(this, 'x and y must be numbers');
-      }
 
-      if (typeof w !== 'number' || typeof h !== 'number') {
-        return _utils.throwError.call(this, 'w and h must be numbers');
+    return i;
+  }
+
+  /**
+   * Returns the hex colour value of a pixel
+   * @param {number} x the x coordinate
+   * @param {number} y the y coordinate
+   * @param {function(Error, Jimp)} cb (optional) a callback for when complete
+   * @returns {number} the color of the pixel
+   */
+  getPixelColor(x, y, cb) {
+    if (typeof x !== 'number' || typeof y !== 'number')
+      return throwError.call(this, 'x and y must be numbers', cb);
+
+    // round input
+    x = Math.round(x);
+    y = Math.round(y);
+
+    const idx = this.getPixelIndex(x, y);
+    const hex = this.bitmap.data.readUInt32BE(idx);
+
+    if (isNodePattern(cb)) {
+      cb.call(this, null, hex);
+    }
+
+    return hex;
+  }
+
+  getPixelColour = this.getPixelColor;
+
+  /**
+   * Returns the hex colour value of a pixel
+   * @param {number} hex color to set
+   * @param {number} x the x coordinate
+   * @param {number} y the y coordinate
+   * @param {function(Error, Jimp)} cb (optional) a callback for when complete
+   * @returns {number} the index of the pixel or -1 if not found
+   */
+  setPixelColor(hex, x, y, cb) {
+    if (
+      typeof hex !== 'number' ||
+      typeof x !== 'number' ||
+      typeof y !== 'number'
+    )
+      return throwError.call(this, 'hex, x and y must be numbers', cb);
+
+    // round input
+    x = Math.round(x);
+    y = Math.round(y);
+
+    const idx = this.getPixelIndex(x, y);
+    this.bitmap.data.writeUInt32BE(hex, idx);
+
+    if (isNodePattern(cb)) {
+      cb.call(this, null, this);
+    }
+
+    return this;
+  }
+
+  setPixelColour = this.setPixelColor;
+
+  /**
+   * Determine if the image contains opaque pixels.
+   * @return {boolean} hasAlpha whether the image contains opaque pixels
+   */
+  hasAlpha() {
+    for (let yIndex = 0; yIndex < this.bitmap.height; yIndex++) {
+      for (let xIndex = 0; xIndex < this.bitmap.width; xIndex++) {
+        const idx = (this.bitmap.width * yIndex + xIndex) << 2;
+        const alpha = this.bitmap.data[idx + 3];
+
+        if (alpha !== 0xff) {
+          return true;
+        }
       }
+    }
+
+    return false;
+  }
 
-      return (0, _utils.scanIterator)(this, x, y, w, h);
+  /**
+   * Iterate scan through a region of the bitmap
+   * @param {number} x the x coordinate to begin the scan at
+   * @param {number} y the y coordinate to begin the scan at
+   * @param w the width of the scan region
+   * @param h the height of the scan region
+   * @returns {IterableIterator<{x: number, y: number, idx: number, image: Jimp}>}
+   */
+  scanIterator(x, y, w, h) {
+    if (typeof x !== 'number' || typeof y !== 'number') {
+      return throwError.call(this, 'x and y must be numbers');
     }
-  }]);
-  return Jimp;
-}(_events["default"]);
 
-function addConstants(constants) {
-  var jimpInstance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Jimp;
-  Object.entries(constants).forEach(function (_ref) {
-    var _ref2 = (0, _slicedToArray2["default"])(_ref, 2),
-        name = _ref2[0],
-        value = _ref2[1];
+    if (typeof w !== 'number' || typeof h !== 'number') {
+      return throwError.call(this, 'w and h must be numbers');
+    }
 
+    return scanIterator(this, x, y, w, h);
+  }
+}
+
+export function addConstants(constants, jimpInstance = Jimp) {
+  Object.entries(constants).forEach(([name, value]) => {
     jimpInstance[name] = value;
   });
 }
 
-function addJimpMethods(methods) {
-  var jimpInstance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Jimp;
-  Object.entries(methods).forEach(function (_ref3) {
-    var _ref4 = (0, _slicedToArray2["default"])(_ref3, 2),
-        name = _ref4[0],
-        value = _ref4[1];
-
+export function addJimpMethods(methods, jimpInstance = Jimp) {
+  Object.entries(methods).forEach(([name, value]) => {
     jimpInstance.prototype[name] = value;
   });
 }
 
 addConstants(constants);
-addJimpMethods({
-  composite: _composite["default"]
-});
+addJimpMethods({ composite });
+
 Jimp.__extraConstructors = [];
+
 /**
  * Allow client libs to add new ways to build a Jimp object.
  * @param {string} name identify the extra constructor.
  * @param {function} test a function that returns true when it accepts the arguments passed to the main constructor.
  * @param {function} run where the magic happens.
  */
-
-Jimp.appendConstructorOption = function (name, test, run) {
-  Jimp.__extraConstructors.push({
-    name: name,
-    test: test,
-    run: run
-  });
+Jimp.appendConstructorOption = function(name, test, run) {
+  Jimp.__extraConstructors.push({ name, test, run });
 };
+
 /**
  * Read an image from a file or a Buffer. Takes the same args as the constructor
  * @returns {Promise} a promise
  */
-
-
-Jimp.read = function () {
-  for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
-    args[_key3] = arguments[_key3];
-  }
-
-  return new Promise(function (resolve, reject) {
-    (0, _construct2["default"])(Jimp, args.concat([function (err, image) {
-      if (err) reject(err);else resolve(image);
-    }]));
+Jimp.read = function(...args) {
+  return new Promise((resolve, reject) => {
+    new Jimp(...args, (err, image) => {
+      if (err) reject(err);
+      else resolve(image);
+    });
   });
 };
 
 Jimp.create = Jimp.read;
+
 /**
  * A static helper method that converts RGBA values to a single integer value
  * @param {number} r the red value (0-255)
@@ -939,90 +889,109 @@ Jimp.create = Jimp.read;
  * @param {function(Error, Jimp)} cb (optional) A callback for when complete
  * @returns {number} an single integer colour value
  */
-
-Jimp.rgbaToInt = function (r, g, b, a, cb) {
-  if (typeof r !== 'number' || typeof g !== 'number' || typeof b !== 'number' || typeof a !== 'number') {
-    return _utils.throwError.call(this, 'r, g, b and a must be numbers', cb);
+Jimp.rgbaToInt = function(r, g, b, a, cb) {
+  if (
+    typeof r !== 'number' ||
+    typeof g !== 'number' ||
+    typeof b !== 'number' ||
+    typeof a !== 'number'
+  ) {
+    return throwError.call(this, 'r, g, b and a must be numbers', cb);
   }
 
   if (r < 0 || r > 255) {
-    return _utils.throwError.call(this, 'r must be between 0 and 255', cb);
+    return throwError.call(this, 'r must be between 0 and 255', cb);
   }
 
   if (g < 0 || g > 255) {
-    _utils.throwError.call(this, 'g must be between 0 and 255', cb);
+    throwError.call(this, 'g must be between 0 and 255', cb);
   }
 
   if (b < 0 || b > 255) {
-    return _utils.throwError.call(this, 'b must be between 0 and 255', cb);
+    return throwError.call(this, 'b must be between 0 and 255', cb);
   }
 
   if (a < 0 || a > 255) {
-    return _utils.throwError.call(this, 'a must be between 0 and 255', cb);
+    return throwError.call(this, 'a must be between 0 and 255', cb);
   }
 
   r = Math.round(r);
   b = Math.round(b);
   g = Math.round(g);
   a = Math.round(a);
-  var i = r * Math.pow(256, 3) + g * Math.pow(256, 2) + b * Math.pow(256, 1) + a * Math.pow(256, 0);
 
-  if ((0, _utils.isNodePattern)(cb)) {
+  const i =
+    r * Math.pow(256, 3) +
+    g * Math.pow(256, 2) +
+    b * Math.pow(256, 1) +
+    a * Math.pow(256, 0);
+
+  if (isNodePattern(cb)) {
     cb.call(this, null, i);
   }
 
   return i;
 };
+
 /**
  * A static helper method that converts RGBA values to a single integer value
  * @param {number} i a single integer value representing an RGBA colour (e.g. 0xFF0000FF for red)
  * @param {function(Error, Jimp)} cb (optional) A callback for when complete
  * @returns {object} an object with the properties r, g, b and a representing RGBA values
  */
-
-
-Jimp.intToRGBA = function (i, cb) {
+Jimp.intToRGBA = function(i, cb) {
   if (typeof i !== 'number') {
-    return _utils.throwError.call(this, 'i must be a number', cb);
+    return throwError.call(this, 'i must be a number', cb);
   }
 
-  var rgba = {};
+  const rgba = {};
+
   rgba.r = Math.floor(i / Math.pow(256, 3));
   rgba.g = Math.floor((i - rgba.r * Math.pow(256, 3)) / Math.pow(256, 2));
-  rgba.b = Math.floor((i - rgba.r * Math.pow(256, 3) - rgba.g * Math.pow(256, 2)) / Math.pow(256, 1));
-  rgba.a = Math.floor((i - rgba.r * Math.pow(256, 3) - rgba.g * Math.pow(256, 2) - rgba.b * Math.pow(256, 1)) / Math.pow(256, 0));
-
-  if ((0, _utils.isNodePattern)(cb)) {
+  rgba.b = Math.floor(
+    (i - rgba.r * Math.pow(256, 3) - rgba.g * Math.pow(256, 2)) /
+      Math.pow(256, 1)
+  );
+  rgba.a = Math.floor(
+    (i -
+      rgba.r * Math.pow(256, 3) -
+      rgba.g * Math.pow(256, 2) -
+      rgba.b * Math.pow(256, 1)) /
+      Math.pow(256, 0)
+  );
+
+  if (isNodePattern(cb)) {
     cb.call(this, null, rgba);
   }
 
   return rgba;
 };
+
 /**
  * Converts a css color (Hex, 8-digit (RGBA) Hex, RGB, RGBA, HSL, HSLA, HSV, HSVA, Named) to a hex number
  * @param {string} cssColor a number
  * @returns {number} a hex number representing a color
  */
-
-
-Jimp.cssColorToHex = function (cssColor) {
+Jimp.cssColorToHex = function(cssColor) {
   cssColor = cssColor || 0; // 0, null, undefined, NaN
 
   if (typeof cssColor === 'number') return Number(cssColor);
-  return parseInt((0, _tinycolor["default"])(cssColor).toHex8(), 16);
+
+  return parseInt(tinyColor(cssColor).toHex8(), 16);
 };
+
 /**
  * Limits a number to between 0 or 255
  * @param {number} n a number
  * @returns {number} the number limited to between 0 or 255
  */
-
-
-Jimp.limit255 = function (n) {
+Jimp.limit255 = function(n) {
   n = Math.max(n, 0);
   n = Math.min(n, 255);
+
   return n;
 };
+
 /**
  * Diffs two images and returns
  * @param {Jimp} img1 a Jimp image to compare
@@ -1030,13 +999,12 @@ Jimp.limit255 = function (n) {
  * @param {number} threshold (optional) a number, 0 to 1, the smaller the value the more sensitive the comparison (default: 0.1)
  * @returns {object} an object { percent: percent similar, diff: a Jimp image highlighting differences }
  */
+Jimp.diff = function(img1, img2, threshold = 0.1) {
+  if (!(img1 instanceof Jimp) || !(img2 instanceof Jimp))
+    return throwError.call(this, 'img1 and img2 must be an Jimp images');
 
-
-Jimp.diff = function (img1, img2) {
-  var threshold = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.1;
-  if (!(img1 instanceof Jimp) || !(img2 instanceof Jimp)) return _utils.throwError.call(this, 'img1 and img2 must be an Jimp images');
-  var bmp1 = img1.bitmap;
-  var bmp2 = img2.bitmap;
+  const bmp1 = img1.bitmap;
+  const bmp2 = img2.bitmap;
 
   if (bmp1.width !== bmp2.width || bmp1.height !== bmp2.height) {
     if (bmp1.width * bmp1.height > bmp2.width * bmp2.height) {
@@ -1049,44 +1017,52 @@ Jimp.diff = function (img1, img2) {
   }
 
   if (typeof threshold !== 'number' || threshold < 0 || threshold > 1) {
-    return _utils.throwError.call(this, 'threshold must be a number between 0 and 1');
+    return throwError.call(this, 'threshold must be a number between 0 and 1');
   }
 
-  var diff = new Jimp(bmp1.width, bmp1.height, 0xffffffff);
-  var numDiffPixels = (0, _pixelmatch["default"])(bmp1.data, bmp2.data, diff.bitmap.data, diff.bitmap.width, diff.bitmap.height, {
-    threshold: threshold
-  });
+  const diff = new Jimp(bmp1.width, bmp1.height, 0xffffffff);
+
+  const numDiffPixels = pixelMatch(
+    bmp1.data,
+    bmp2.data,
+    diff.bitmap.data,
+    diff.bitmap.width,
+    diff.bitmap.height,
+    { threshold }
+  );
+
   return {
     percent: numDiffPixels / (diff.bitmap.width * diff.bitmap.height),
     image: diff
   };
 };
+
 /**
  * Calculates the hamming distance of two images based on their perceptual hash
  * @param {Jimp} img1 a Jimp image to compare
  * @param {Jimp} img2 a Jimp image to compare
  * @returns {number} a number ranging from 0 to 1, 0 means they are believed to be identical
  */
+Jimp.distance = function(img1, img2) {
+  const phash = new ImagePHash();
+  const hash1 = phash.getHash(img1);
+  const hash2 = phash.getHash(img2);
 
-
-Jimp.distance = function (img1, img2) {
-  var phash = new _phash["default"]();
-  var hash1 = phash.getHash(img1);
-  var hash2 = phash.getHash(img2);
   return phash.distance(hash1, hash2);
 };
+
 /**
  * Calculates the hamming distance of two images based on their perceptual hash
  * @param {hash} hash1 a pHash
  * @param {hash} hash2 a pHash
  * @returns {number} a number ranging from 0 to 1, 0 means they are believed to be identical
  */
+Jimp.compareHashes = function(hash1, hash2) {
+  const phash = new ImagePHash();
 
-
-Jimp.compareHashes = function (hash1, hash2) {
-  var phash = new _phash["default"]();
   return phash.distance(hash1, hash2);
 };
+
 /**
  * Compute color difference
  * 0 means no difference, 1 means maximum difference.
@@ -1096,15 +1072,10 @@ Jimp.compareHashes = function (hash1, hash2) {
  * Where `a` is optional and `val` is an integer between 0 and 255.
  * @returns {number} float between 0 and 1.
  */
-
-
-Jimp.colorDiff = function (rgba1, rgba2) {
-  var pow = function pow(n) {
-    return Math.pow(n, 2);
-  };
-
-  var max = Math.max;
-  var maxVal = 255 * 255 * 3;
+Jimp.colorDiff = function(rgba1, rgba2) {
+  const pow = n => Math.pow(n, 2);
+  const { max } = Math;
+  const maxVal = 255 * 255 * 3;
 
   if (rgba1.a !== 0 && !rgba1.a) {
     rgba1.a = 255;
@@ -1114,8 +1085,14 @@ Jimp.colorDiff = function (rgba1, rgba2) {
     rgba2.a = 255;
   }
 
-  return (max(pow(rgba1.r - rgba2.r), pow(rgba1.r - rgba2.r - rgba1.a + rgba2.a)) + max(pow(rgba1.g - rgba2.g), pow(rgba1.g - rgba2.g - rgba1.a + rgba2.a)) + max(pow(rgba1.b - rgba2.b), pow(rgba1.b - rgba2.b - rgba1.a + rgba2.a))) / maxVal;
+  return (
+    (max(pow(rgba1.r - rgba2.r), pow(rgba1.r - rgba2.r - rgba1.a + rgba2.a)) +
+      max(pow(rgba1.g - rgba2.g), pow(rgba1.g - rgba2.g - rgba1.a + rgba2.a)) +
+      max(pow(rgba1.b - rgba2.b), pow(rgba1.b - rgba2.b - rgba1.a + rgba2.a))) /
+    maxVal
+  );
 };
+
 /**
  * Helper to create Jimp methods that emit events before and after its execution.
  * @param {string} methodName   The name to be appended to Jimp prototype.
@@ -1130,35 +1107,25 @@ Jimp.colorDiff = function (rgba1, rgba2) {
  * The emitted event comes with a object parameter to the listener with the
  * `methodName` as one attribute.
  */
+export function jimpEvMethod(methodName, evName, method) {
+  const evNameBefore = 'before-' + evName;
+  const evNameAfter = evName.replace(/e$/, '') + 'ed';
 
-
-function jimpEvMethod(methodName, evName, method) {
-  var evNameBefore = 'before-' + evName;
-  var evNameAfter = evName.replace(/e$/, '') + 'ed';
-
-  Jimp.prototype[methodName] = function () {
-    var wrappedCb;
-
-    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
-      args[_key4] = arguments[_key4];
-    }
-
-    var cb = args[method.length - 1];
-    var jimpInstance = this;
+  Jimp.prototype[methodName] = function(...args) {
+    let wrappedCb;
+    const cb = args[method.length - 1];
+    const jimpInstance = this;
 
     if (typeof cb === 'function') {
-      wrappedCb = function wrappedCb() {
-        for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
-          args[_key5] = arguments[_key5];
-        }
-
-        var err = args[0],
-            data = args[1];
+      wrappedCb = function(...args) {
+        const [err, data] = args;
 
         if (err) {
           jimpInstance.emitError(methodName, err);
         } else {
-          jimpInstance.emitMulti(methodName, evNameAfter, (0, _defineProperty2["default"])({}, methodName, data));
+          jimpInstance.emitMulti(methodName, evNameAfter, {
+            [methodName]: data
+          });
         }
 
         cb.apply(this, args);
@@ -1170,13 +1137,16 @@ function jimpEvMethod(methodName, evName, method) {
     }
 
     this.emitMulti(methodName, evNameBefore);
-    var result;
+
+    let result;
 
     try {
       result = method.apply(this, args);
 
       if (!wrappedCb) {
-        this.emitMulti(methodName, evNameAfter, (0, _defineProperty2["default"])({}, methodName, result));
+        this.emitMulti(methodName, evNameAfter, {
+          [methodName]: result
+        });
       }
     } catch (error) {
       error.methodName = methodName;
@@ -1188,52 +1158,51 @@ function jimpEvMethod(methodName, evName, method) {
 
   Jimp.prototype[methodName + 'Quiet'] = method;
 }
+
 /**
  * Creates a new image that is a clone of this one.
  * @param {function(Error, Jimp)} cb (optional) A callback for when complete
  * @returns the new image
  */
+jimpEvMethod('clone', 'clone', function(cb) {
+  const clone = new Jimp(this);
 
-
-jimpEvMethod('clone', 'clone', function (cb) {
-  var clone = new Jimp(this);
-
-  if ((0, _utils.isNodePattern)(cb)) {
+  if (isNodePattern(cb)) {
     cb.call(clone, null, clone);
   }
 
   return clone;
 });
+
 /**
  * Simplify jimpEvMethod call for the common `change` evName.
  * @param {string} methodName name of the method
  * @param {function} method to watch changes for
  */
-
-function jimpEvChange(methodName, method) {
+export function jimpEvChange(methodName, method) {
   jimpEvMethod(methodName, 'change', method);
 }
+
 /**
  * Sets the type of the image (RGB or RGBA) when saving as PNG format (default is RGBA)
  * @param b A Boolean, true to use RGBA or false to use RGB
  * @param {function(Error, Jimp)} cb (optional) a callback for when complete
  * @returns {Jimp} this for chaining of methods
  */
-
-
-jimpEvChange('background', function (hex, cb) {
+jimpEvChange('background', function(hex, cb) {
   if (typeof hex !== 'number') {
-    return _utils.throwError.call(this, 'hex must be a hexadecimal rgba value', cb);
+    return throwError.call(this, 'hex must be a hexadecimal rgba value', cb);
   }
 
   this._background = hex;
 
-  if ((0, _utils.isNodePattern)(cb)) {
+  if (isNodePattern(cb)) {
     cb.call(this, null, this);
   }
 
   return this;
 });
+
 /**
  * Scans through a region of the bitmap, calling a function for each pixel.
  * @param {number} x the x coordinate to begin the scan at
@@ -1245,23 +1214,22 @@ jimpEvChange('background', function (hex, cb) {
  * @param {function(Error, Jimp)} cb (optional) a callback for when complete
  * @returns {Jimp} this for chaining of methods
  */
-
-jimpEvChange('scan', function (x, y, w, h, f, cb) {
+jimpEvChange('scan', function(x, y, w, h, f, cb) {
   if (typeof x !== 'number' || typeof y !== 'number') {
-    return _utils.throwError.call(this, 'x and y must be numbers', cb);
+    return throwError.call(this, 'x and y must be numbers', cb);
   }
 
   if (typeof w !== 'number' || typeof h !== 'number') {
-    return _utils.throwError.call(this, 'w and h must be numbers', cb);
+    return throwError.call(this, 'w and h must be numbers', cb);
   }
 
   if (typeof f !== 'function') {
-    return _utils.throwError.call(this, 'f must be a function', cb);
+    return throwError.call(this, 'f must be a function', cb);
   }
 
-  var result = (0, _utils.scan)(this, x, y, w, h, f);
+  const result = scan(this, x, y, w, h, f);
 
-  if ((0, _utils.isNodePattern)(cb)) {
+  if (isNodePattern(cb)) {
     cb.call(this, null, result);
   }
 
@@ -1270,15 +1238,14 @@ jimpEvChange('scan', function (x, y, w, h, f, cb) {
 
 if (process.env.ENVIRONMENT === 'BROWSER') {
   // For use in a web browser or web worker
-
   /* global self */
-  var gl;
+  let gl;
 
-  if (typeof window !== 'undefined' && (typeof window === "undefined" ? "undefined" : (0, _typeof2["default"])(window)) === 'object') {
+  if (typeof window !== 'undefined' && typeof window === 'object') {
     gl = window;
   }
 
-  if (typeof self !== 'undefined' && (typeof self === "undefined" ? "undefined" : (0, _typeof2["default"])(self)) === 'object') {
+  if (typeof self !== 'undefined' && typeof self === 'object') {
     gl = self;
   }
 
@@ -1286,6 +1253,6 @@ if (process.env.ENVIRONMENT === 'BROWSER') {
   gl.Buffer = Buffer;
 }
 
-var _default = Jimp;
-exports["default"] = _default;
-//# sourceMappingURL=index.js.map
\ No newline at end of file
+export { addType } from './utils/mime';
+
+export default Jimp;
diff --git a/node_modules/@jimp/core/es/index.js.map b/node_modules/@jimp/core/es/index.js.map
deleted file mode 100644
index 8e69060..0000000
--- a/node_modules/@jimp/core/es/index.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"sources":["../src/index.js"],"names":["alphabet","maxHashLength","NaN","i","maxHash","anyBase","BIN","slice","Array","join","push","length","noop","isArrayBuffer","test","Object","prototype","toString","call","toLowerCase","indexOf","bufferFromArrayBuffer","arrayBuffer","buffer","Buffer","alloc","byteLength","view","Uint8Array","loadFromURL","options","cb","err","response","data","headers","url","location","isBuffer","msg","statusCode","Error","loadBufferFromPath","src","fs","readFile","match","isRawRGBAData","obj","width","height","Uint8ClampedArray","makeRGBABufferFromRGB","rgbaBuffer","allocUnsafe","j","emptyBitmap","Jimp","args","MIME_PNG","path","write","mime","getBase64","getBuffer","getBufferAsync","getPixelColor","setPixelColor","jimpInstance","finish","evData","methodName","setTimeout","emitError","emitMulti","parseInt","w","h","_background","cssColorToHex","throwError","bitmap","writeUInt32BE","parseBitmap","original","from","_quality","_deflateLevel","_deflateStrategy","_filterType","_rgba","_originalMime","imageData","isRGBA","extraConstructor","__extraConstructors","find","c","Promise","resolve","reject","run","then","bool","eventName","assign","emit","getMIME","MIME","getExtension","createWriteStream","getType","pathObj","Path","parse","dir","mkdirp","sync","stream","on","end","AUTO","base","hash","pHash","ImagePHash","getHash","compareHash","currentHash","distance","x","y","edgeHandling","xi","yi","EDGE_EXTEND","Math","round","EDGE_WRAP","idx","getPixelIndex","hex","readUInt32BE","yIndex","xIndex","alpha","EventEmitter","addConstants","constants","entries","forEach","name","value","addJimpMethods","methods","composite","appendConstructorOption","read","image","create","rgbaToInt","r","g","b","a","pow","intToRGBA","rgba","floor","cssColor","Number","toHex8","limit255","n","max","min","diff","img1","img2","threshold","bmp1","bmp2","cloneQuiet","resize","numDiffPixels","percent","phash","hash1","hash2","compareHashes","colorDiff","rgba1","rgba2","maxVal","jimpEvMethod","evName","method","evNameBefore","evNameAfter","replace","wrappedCb","apply","result","error","clone","jimpEvChange","f","process","env","ENVIRONMENT","gl","window","self"],"mappings":"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","sourcesContent":["import fs from 'fs';\nimport Path from 'path';\nimport EventEmitter from 'events';\n\nimport { isNodePattern, throwError, scan, scanIterator } from '@jimp/utils';\nimport anyBase from 'any-base';\nimport mkdirp from 'mkdirp';\nimport pixelMatch from 'pixelmatch';\nimport tinyColor from 'tinycolor2';\n\nimport ImagePHash from './modules/phash';\nimport request from './request';\n\nimport composite from './composite';\nimport promisify from './utils/promisify';\nimport * as MIME from './utils/mime';\nimport { parseBitmap, getBuffer, getBufferAsync } from './utils/image-bitmap';\nimport * as constants from './constants';\n\nconst alphabet =\n  '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_';\n\n// an array storing the maximum string length of hashes at various bases\n// 0 and 1 do not exist as possible hash lengths\nconst maxHashLength = [NaN, NaN];\n\nfor (let i = 2; i < 65; i++) {\n  const maxHash = anyBase(anyBase.BIN, alphabet.slice(0, i))(\n    new Array(64 + 1).join('1')\n  );\n  maxHashLength.push(maxHash.length);\n}\n\n// no operation\nfunction noop() {}\n\n// error checking methods\n\nfunction isArrayBuffer(test) {\n  return (\n    Object.prototype.toString\n      .call(test)\n      .toLowerCase()\n      .indexOf('arraybuffer') > -1\n  );\n}\n\n// Prepare a Buffer object from the arrayBuffer. Necessary in the browser > node conversion,\n// But this function is not useful when running in node directly\nfunction bufferFromArrayBuffer(arrayBuffer) {\n  const buffer = Buffer.alloc(arrayBuffer.byteLength);\n  const view = new Uint8Array(arrayBuffer);\n\n  for (let i = 0; i < buffer.length; ++i) {\n    buffer[i] = view[i];\n  }\n\n  return buffer;\n}\n\nfunction loadFromURL(options, cb) {\n  request(options, (err, response, data) => {\n    if (err) {\n      return cb(err);\n    }\n\n    if ('headers' in response && 'location' in response.headers) {\n      options.url = response.headers.location;\n      return loadFromURL(options, cb);\n    }\n\n    if (typeof data === 'object' && Buffer.isBuffer(data)) {\n      return cb(null, data);\n    }\n\n    const msg =\n      'Could not load Buffer from <' +\n      options.url +\n      '> ' +\n      '(HTTP: ' +\n      response.statusCode +\n      ')';\n\n    return new Error(msg);\n  });\n}\n\nfunction loadBufferFromPath(src, cb) {\n  if (\n    fs &&\n    typeof fs.readFile === 'function' &&\n    !src.match(/^(http|ftp)s?:\\/\\/./)\n  ) {\n    fs.readFile(src, cb);\n  } else {\n    loadFromURL({ url: src }, cb);\n  }\n}\n\nfunction isRawRGBAData(obj) {\n  return (\n    obj &&\n    typeof obj === 'object' &&\n    typeof obj.width === 'number' &&\n    typeof obj.height === 'number' &&\n    (Buffer.isBuffer(obj.data) ||\n      obj.data instanceof Uint8Array ||\n      (typeof Uint8ClampedArray === 'function' &&\n        obj.data instanceof Uint8ClampedArray)) &&\n    (obj.data.length === obj.width * obj.height * 4 ||\n      obj.data.length === obj.width * obj.height * 3)\n  );\n}\n\nfunction makeRGBABufferFromRGB(buffer) {\n  if (buffer.length % 3 !== 0) {\n    throw new Error('Buffer length is incorrect');\n  }\n\n  const rgbaBuffer = Buffer.allocUnsafe((buffer.length / 3) * 4);\n  let j = 0;\n\n  for (let i = 0; i < buffer.length; i++) {\n    rgbaBuffer[j] = buffer[i];\n\n    if ((i + 1) % 3 === 0) {\n      rgbaBuffer[++j] = 255;\n    }\n\n    j++;\n  }\n\n  return rgbaBuffer;\n}\n\nconst emptyBitmap = {\n  data: null,\n  width: null,\n  height: null\n};\n\n/**\n * Jimp constructor (from a file)\n * @param path a path to the image\n * @param {function(Error, Jimp)} cb (optional) a function to call when the image is parsed to a bitmap\n */\n\n/**\n * Jimp constructor (from a url with options)\n * @param options { url, otherOptions}\n * @param {function(Error, Jimp)} cb (optional) a function to call when the image is parsed to a bitmap\n */\n\n/**\n * Jimp constructor (from another Jimp image or raw image data)\n * @param image a Jimp image to clone\n * @param {function(Error, Jimp)} cb a function to call when the image is parsed to a bitmap\n */\n\n/**\n * Jimp constructor (from a Buffer)\n * @param data a Buffer containing the image data\n * @param {function(Error, Jimp)} cb a function to call when the image is parsed to a bitmap\n */\n\n/**\n * Jimp constructor (to generate a new image)\n * @param w the width of the image\n * @param h the height of the image\n * @param {function(Error, Jimp)} cb (optional) a function to call when the image is parsed to a bitmap\n */\n\n/**\n * Jimp constructor (to generate a new image)\n * @param w the width of the image\n * @param h the height of the image\n * @param background color to fill the image with\n * @param {function(Error, Jimp)} cb (optional) a function to call when the image is parsed to a bitmap\n */\n\nclass Jimp extends EventEmitter {\n  // An object representing a bitmap in memory, comprising:\n  //  - data: a buffer of the bitmap data\n  //  - width: the width of the image in pixels\n  //  - height: the height of the image in pixels\n  bitmap = emptyBitmap;\n\n  // Default colour to use for new pixels\n  _background = 0x00000000;\n\n  // Default MIME is PNG\n  _originalMime = Jimp.MIME_PNG;\n\n  // Exif data for the image\n  _exif = null;\n\n  // Whether Transparency supporting formats will be exported as RGB or RGBA\n  _rgba = true;\n\n  constructor(...args) {\n    super();\n\n    const jimpInstance = this;\n    let cb = noop;\n\n    if (isArrayBuffer(args[0])) {\n      args[0] = bufferFromArrayBuffer(args[0]);\n    }\n\n    function finish(...args) {\n      const [err] = args;\n      const evData = err || {};\n      evData.methodName = 'constructor';\n\n      setTimeout(() => {\n        // run on next tick.\n        if (err && cb === noop) {\n          jimpInstance.emitError('constructor', err);\n        } else if (!err) {\n          jimpInstance.emitMulti('constructor', 'initialized');\n        }\n\n        cb.call(jimpInstance, ...args);\n      }, 1);\n    }\n\n    if (\n      (typeof args[0] === 'number' && typeof args[1] === 'number') ||\n      (parseInt(args[0], 10) && parseInt(args[1], 10))\n    ) {\n      // create a new image\n      const w = parseInt(args[0], 10);\n      const h = parseInt(args[1], 10);\n      cb = args[2];\n\n      // with a hex color\n      if (typeof args[2] === 'number') {\n        this._background = args[2];\n        cb = args[3];\n      }\n\n      // with a css color\n      if (typeof args[2] === 'string') {\n        this._background = Jimp.cssColorToHex(args[2]);\n        cb = args[3];\n      }\n\n      if (typeof cb === 'undefined') {\n        cb = noop;\n      }\n\n      if (typeof cb !== 'function') {\n        return throwError.call(this, 'cb must be a function', finish);\n      }\n\n      this.bitmap = {\n        data: Buffer.alloc(w * h * 4),\n        width: w,\n        height: h\n      };\n\n      for (let i = 0; i < this.bitmap.data.length; i += 4) {\n        this.bitmap.data.writeUInt32BE(this._background, i);\n      }\n\n      finish(null, this);\n    } else if (typeof args[0] === 'object' && args[0].url) {\n      cb = args[1] || noop;\n\n      if (typeof cb !== 'function') {\n        return throwError.call(this, 'cb must be a function', finish);\n      }\n\n      loadFromURL(args[0], (err, data) => {\n        if (err) {\n          return throwError.call(this, err, finish);\n        }\n\n        this.parseBitmap(data, args[0].url, finish);\n      });\n    } else if (args[0] instanceof Jimp) {\n      // clone an existing Jimp\n      const [original] = args;\n      cb = args[1];\n\n      if (typeof cb === 'undefined') {\n        cb = noop;\n      }\n\n      if (typeof cb !== 'function') {\n        return throwError.call(this, 'cb must be a function', finish);\n      }\n\n      this.bitmap = {\n        data: Buffer.from(original.bitmap.data),\n        width: original.bitmap.width,\n        height: original.bitmap.height\n      };\n\n      this._quality = original._quality;\n      this._deflateLevel = original._deflateLevel;\n      this._deflateStrategy = original._deflateStrategy;\n      this._filterType = original._filterType;\n      this._rgba = original._rgba;\n      this._background = original._background;\n      this._originalMime = original._originalMime;\n\n      finish(null, this);\n    } else if (isRawRGBAData(args[0])) {\n      const [imageData] = args;\n      cb = args[1] || noop;\n\n      const isRGBA =\n        imageData.width * imageData.height * 4 === imageData.data.length;\n      const buffer = isRGBA\n        ? Buffer.from(imageData.data)\n        : makeRGBABufferFromRGB(imageData.data);\n\n      this.bitmap = {\n        data: buffer,\n        width: imageData.width,\n        height: imageData.height\n      };\n\n      finish(null, this);\n    } else if (typeof args[0] === 'string') {\n      // read from a path\n      const path = args[0];\n      cb = args[1];\n\n      if (typeof cb === 'undefined') {\n        cb = noop;\n      }\n\n      if (typeof cb !== 'function') {\n        return throwError.call(this, 'cb must be a function', finish);\n      }\n\n      loadBufferFromPath(path, (err, data) => {\n        if (err) {\n          return throwError.call(this, err, finish);\n        }\n\n        this.parseBitmap(data, path, finish);\n      });\n    } else if (typeof args[0] === 'object' && Buffer.isBuffer(args[0])) {\n      // read from a buffer\n      const data = args[0];\n      cb = args[1];\n\n      if (typeof cb !== 'function') {\n        return throwError.call(this, 'cb must be a function', finish);\n      }\n\n      this.parseBitmap(data, null, finish);\n    } else {\n      // Allow client libs to add new ways to build a Jimp object.\n      // Extra constructors must be added by `Jimp.appendConstructorOption()`\n      cb = args[args.length - 1];\n\n      if (typeof cb !== 'function') {\n        // TODO: try to solve the args after cb problem.\n        cb = args[args.length - 2];\n\n        if (typeof cb !== 'function') {\n          cb = noop;\n        }\n      }\n\n      const extraConstructor = Jimp.__extraConstructors.find(c =>\n        c.test(...args)\n      );\n\n      if (extraConstructor) {\n        new Promise((resolve, reject) =>\n          extraConstructor.run.call(this, resolve, reject, ...args)\n        )\n          .then(() => finish(null, this))\n          .catch(finish);\n      } else {\n        return throwError.call(\n          this,\n          'No matching constructor overloading was found. ' +\n            'Please see the docs for how to call the Jimp constructor.',\n          finish\n        );\n      }\n    }\n  }\n\n  /**\n   * Parse a bitmap with the loaded image types.\n   *\n   * @param {Buffer} data raw image data\n   * @param {string} path optional path to file\n   * @param {function(Error, Jimp)} finish (optional) a callback for when complete\n   * @memberof Jimp\n   */\n  parseBitmap(data, path, finish) {\n    parseBitmap.call(this, data, null, finish);\n  }\n\n  /**\n   * Sets the type of the image (RGB or RGBA) when saving in a format that supports transparency (default is RGBA)\n   * @param {boolean} bool A Boolean, true to use RGBA or false to use RGB\n   * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n   * @returns {Jimp} this for chaining of methods\n   */\n  rgba(bool, cb) {\n    if (typeof bool !== 'boolean') {\n      return throwError.call(\n        this,\n        'bool must be a boolean, true for RGBA or false for RGB',\n        cb\n      );\n    }\n\n    this._rgba = bool;\n\n    if (isNodePattern(cb)) {\n      cb.call(this, null, this);\n    }\n\n    return this;\n  }\n\n  /**\n   * Emit for multiple listeners\n   * @param {string} methodName name of the method to emit an error for\n   * @param {string} eventName name of the eventName to emit an error for\n   * @param {object} data to emit\n   */\n  emitMulti(methodName, eventName, data = {}) {\n    data = Object.assign(data, { methodName, eventName });\n    this.emit('any', data);\n\n    if (methodName) {\n      this.emit(methodName, data);\n    }\n\n    this.emit(eventName, data);\n  }\n\n  emitError(methodName, err) {\n    this.emitMulti(methodName, 'error', err);\n  }\n\n  /**\n   * Get the current height of the image\n   * @return {number} height of the image\n   */\n  getHeight() {\n    return this.bitmap.height;\n  }\n\n  /**\n   * Get the current width of the image\n   * @return {number} width of the image\n   */\n  getWidth() {\n    return this.bitmap.width;\n  }\n\n  /**\n   * Nicely format Jimp object when sent to the console e.g. console.log(image)\n   * @returns {string} pretty printed\n   */\n  inspect() {\n    return (\n      '<Jimp ' +\n      (this.bitmap === emptyBitmap\n        ? 'pending...'\n        : this.bitmap.width + 'x' + this.bitmap.height) +\n      '>'\n    );\n  }\n\n  /**\n   * Nicely format Jimp object when converted to a string\n   * @returns {string} pretty printed\n   */\n  toString() {\n    return '[object Jimp]';\n  }\n\n  /**\n   * Returns the original MIME of the image (default: \"image/png\")\n   * @returns {string} the MIME\n   */\n  getMIME() {\n    const mime = this._originalMime || Jimp.MIME_PNG;\n\n    return mime;\n  }\n\n  /**\n   * Returns the appropriate file extension for the original MIME of the image (default: \"png\")\n   * @returns {string} the file extension\n   */\n  getExtension() {\n    const mime = this.getMIME();\n\n    return MIME.getExtension(mime);\n  }\n\n  /**\n   * Writes the image to a file\n   * @param {string} path a path to the destination file\n   * @param {function(Error, Jimp)} cb (optional) a function to call when the image is saved to disk\n   * @returns {Jimp} this for chaining of methods\n   */\n  write(path, cb) {\n    if (!fs || !fs.createWriteStream) {\n      throw new Error(\n        'Cant access the filesystem. You can use the getBase64 method.'\n      );\n    }\n\n    if (typeof path !== 'string') {\n      return throwError.call(this, 'path must be a string', cb);\n    }\n\n    if (typeof cb === 'undefined') {\n      cb = noop;\n    }\n\n    if (typeof cb !== 'function') {\n      return throwError.call(this, 'cb must be a function', cb);\n    }\n\n    const mime = MIME.getType(path) || this.getMIME();\n    const pathObj = Path.parse(path);\n\n    if (pathObj.dir) {\n      mkdirp.sync(pathObj.dir);\n    }\n\n    this.getBuffer(mime, (err, buffer) => {\n      if (err) {\n        return throwError.call(this, err, cb);\n      }\n\n      const stream = fs.createWriteStream(path);\n\n      stream\n        .on('open', () => {\n          stream.write(buffer);\n          stream.end();\n        })\n        .on('error', err => {\n          return throwError.call(this, err, cb);\n        });\n      stream.on('finish', () => {\n        cb.call(this, null, this);\n      });\n    });\n\n    return this;\n  }\n\n  writeAsync = path => promisify(this.write, this, path);\n\n  /**\n   * Converts the image to a base 64 string\n   * @param {string} mime the mime type of the image data to be created\n   * @param {function(Error, Jimp)} cb a Node-style function to call with the buffer as the second argument\n   * @returns {Jimp} this for chaining of methods\n   */\n  getBase64(mime, cb) {\n    if (mime === Jimp.AUTO) {\n      // allow auto MIME detection\n      mime = this.getMIME();\n    }\n\n    if (typeof mime !== 'string') {\n      return throwError.call(this, 'mime must be a string', cb);\n    }\n\n    if (typeof cb !== 'function') {\n      return throwError.call(this, 'cb must be a function', cb);\n    }\n\n    this.getBuffer(mime, function(err, data) {\n      if (err) {\n        return throwError.call(this, err, cb);\n      }\n\n      const src = 'data:' + mime + ';base64,' + data.toString('base64');\n      cb.call(this, null, src);\n    });\n\n    return this;\n  }\n\n  getBase64Async = mime => promisify(this.getBase64, this, mime);\n\n  /**\n   * Generates a perceptual hash of the image <https://en.wikipedia.org/wiki/Perceptual_hashing>. And pads the string. Can configure base.\n   * @param {number} base (optional) a number between 2 and 64 representing the base for the hash (e.g. 2 is binary, 10 is decimal, 16 is hex, 64 is base 64). Defaults to 64.\n   * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n   * @returns {string} a string representing the hash\n   */\n  hash(base, cb) {\n    base = base || 64;\n\n    if (typeof base === 'function') {\n      cb = base;\n      base = 64;\n    }\n\n    if (typeof base !== 'number') {\n      return throwError.call(this, 'base must be a number', cb);\n    }\n\n    if (base < 2 || base > 64) {\n      return throwError.call(\n        this,\n        'base must be a number between 2 and 64',\n        cb\n      );\n    }\n\n    let hash = this.pHash();\n    hash = anyBase(anyBase.BIN, alphabet.slice(0, base))(hash);\n\n    while (hash.length < maxHashLength[base]) {\n      hash = '0' + hash; // pad out with leading zeros\n    }\n\n    if (isNodePattern(cb)) {\n      cb.call(this, null, hash);\n    }\n\n    return hash;\n  }\n\n  /**\n   * Calculates the perceptual hash\n   * @returns {number} the perceptual hash\n   */\n  pHash() {\n    const pHash = new ImagePHash();\n    return pHash.getHash(this);\n  }\n\n  /**\n   * Calculates the hamming distance of the current image and a hash based on their perceptual hash\n   * @param {hash} compareHash hash to compare to\n   * @returns {number} a number ranging from 0 to 1, 0 means they are believed to be identical\n   */\n  distanceFromHash(compareHash) {\n    const pHash = new ImagePHash();\n    const currentHash = pHash.getHash(this);\n\n    return pHash.distance(currentHash, compareHash);\n  }\n\n  /**\n   * Converts the image to a buffer\n   * @param {string} mime the mime type of the image buffer to be created\n   * @param {function(Error, Jimp)} cb a Node-style function to call with the buffer as the second argument\n   * @returns {Jimp} this for chaining of methods\n   */\n  getBuffer = getBuffer;\n\n  getBufferAsync = getBufferAsync;\n\n  /**\n   * Returns the offset of a pixel in the bitmap buffer\n   * @param {number} x the x coordinate\n   * @param {number} y the y coordinate\n   * @param {string} edgeHandling (optional) define how to sum pixels from outside the border\n   * @param {number} cb (optional) a callback for when complete\n   * @returns {number} the index of the pixel or -1 if not found\n   */\n  getPixelIndex(x, y, edgeHandling, cb) {\n    let xi;\n    let yi;\n\n    if (typeof edgeHandling === 'function' && typeof cb === 'undefined') {\n      cb = edgeHandling;\n      edgeHandling = null;\n    }\n\n    if (!edgeHandling) {\n      edgeHandling = Jimp.EDGE_EXTEND;\n    }\n\n    if (typeof x !== 'number' || typeof y !== 'number') {\n      return throwError.call(this, 'x and y must be numbers', cb);\n    }\n\n    // round input\n    x = Math.round(x);\n    y = Math.round(y);\n    xi = x;\n    yi = y;\n\n    if (edgeHandling === Jimp.EDGE_EXTEND) {\n      if (x < 0) xi = 0;\n      if (x >= this.bitmap.width) xi = this.bitmap.width - 1;\n      if (y < 0) yi = 0;\n      if (y >= this.bitmap.height) yi = this.bitmap.height - 1;\n    }\n\n    if (edgeHandling === Jimp.EDGE_WRAP) {\n      if (x < 0) {\n        xi = this.bitmap.width + x;\n      }\n\n      if (x >= this.bitmap.width) {\n        xi = x % this.bitmap.width;\n      }\n\n      if (y < 0) {\n        xi = this.bitmap.height + y;\n      }\n\n      if (y >= this.bitmap.height) {\n        yi = y % this.bitmap.height;\n      }\n    }\n\n    let i = (this.bitmap.width * yi + xi) << 2;\n\n    // if out of bounds index is -1\n    if (xi < 0 || xi >= this.bitmap.width) {\n      i = -1;\n    }\n\n    if (yi < 0 || yi >= this.bitmap.height) {\n      i = -1;\n    }\n\n    if (isNodePattern(cb)) {\n      cb.call(this, null, i);\n    }\n\n    return i;\n  }\n\n  /**\n   * Returns the hex colour value of a pixel\n   * @param {number} x the x coordinate\n   * @param {number} y the y coordinate\n   * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n   * @returns {number} the color of the pixel\n   */\n  getPixelColor(x, y, cb) {\n    if (typeof x !== 'number' || typeof y !== 'number')\n      return throwError.call(this, 'x and y must be numbers', cb);\n\n    // round input\n    x = Math.round(x);\n    y = Math.round(y);\n\n    const idx = this.getPixelIndex(x, y);\n    const hex = this.bitmap.data.readUInt32BE(idx);\n\n    if (isNodePattern(cb)) {\n      cb.call(this, null, hex);\n    }\n\n    return hex;\n  }\n\n  getPixelColour = this.getPixelColor;\n\n  /**\n   * Returns the hex colour value of a pixel\n   * @param {number} hex color to set\n   * @param {number} x the x coordinate\n   * @param {number} y the y coordinate\n   * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n   * @returns {number} the index of the pixel or -1 if not found\n   */\n  setPixelColor(hex, x, y, cb) {\n    if (\n      typeof hex !== 'number' ||\n      typeof x !== 'number' ||\n      typeof y !== 'number'\n    )\n      return throwError.call(this, 'hex, x and y must be numbers', cb);\n\n    // round input\n    x = Math.round(x);\n    y = Math.round(y);\n\n    const idx = this.getPixelIndex(x, y);\n    this.bitmap.data.writeUInt32BE(hex, idx);\n\n    if (isNodePattern(cb)) {\n      cb.call(this, null, this);\n    }\n\n    return this;\n  }\n\n  setPixelColour = this.setPixelColor;\n\n  /**\n   * Determine if the image contains opaque pixels.\n   * @return {boolean} hasAlpha whether the image contains opaque pixels\n   */\n  hasAlpha() {\n    for (let yIndex = 0; yIndex < this.bitmap.height; yIndex++) {\n      for (let xIndex = 0; xIndex < this.bitmap.width; xIndex++) {\n        const idx = (this.bitmap.width * yIndex + xIndex) << 2;\n        const alpha = this.bitmap.data[idx + 3];\n\n        if (alpha !== 0xff) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Iterate scan through a region of the bitmap\n   * @param {number} x the x coordinate to begin the scan at\n   * @param {number} y the y coordinate to begin the scan at\n   * @param w the width of the scan region\n   * @param h the height of the scan region\n   * @returns {IterableIterator<{x: number, y: number, idx: number, image: Jimp}>}\n   */\n  scanIterator(x, y, w, h) {\n    if (typeof x !== 'number' || typeof y !== 'number') {\n      return throwError.call(this, 'x and y must be numbers');\n    }\n\n    if (typeof w !== 'number' || typeof h !== 'number') {\n      return throwError.call(this, 'w and h must be numbers');\n    }\n\n    return scanIterator(this, x, y, w, h);\n  }\n}\n\nexport function addConstants(constants, jimpInstance = Jimp) {\n  Object.entries(constants).forEach(([name, value]) => {\n    jimpInstance[name] = value;\n  });\n}\n\nexport function addJimpMethods(methods, jimpInstance = Jimp) {\n  Object.entries(methods).forEach(([name, value]) => {\n    jimpInstance.prototype[name] = value;\n  });\n}\n\naddConstants(constants);\naddJimpMethods({ composite });\n\nJimp.__extraConstructors = [];\n\n/**\n * Allow client libs to add new ways to build a Jimp object.\n * @param {string} name identify the extra constructor.\n * @param {function} test a function that returns true when it accepts the arguments passed to the main constructor.\n * @param {function} run where the magic happens.\n */\nJimp.appendConstructorOption = function(name, test, run) {\n  Jimp.__extraConstructors.push({ name, test, run });\n};\n\n/**\n * Read an image from a file or a Buffer. Takes the same args as the constructor\n * @returns {Promise} a promise\n */\nJimp.read = function(...args) {\n  return new Promise((resolve, reject) => {\n    new Jimp(...args, (err, image) => {\n      if (err) reject(err);\n      else resolve(image);\n    });\n  });\n};\n\nJimp.create = Jimp.read;\n\n/**\n * A static helper method that converts RGBA values to a single integer value\n * @param {number} r the red value (0-255)\n * @param {number} g the green value (0-255)\n * @param {number} b the blue value (0-255)\n * @param {number} a the alpha value (0-255)\n * @param {function(Error, Jimp)} cb (optional) A callback for when complete\n * @returns {number} an single integer colour value\n */\nJimp.rgbaToInt = function(r, g, b, a, cb) {\n  if (\n    typeof r !== 'number' ||\n    typeof g !== 'number' ||\n    typeof b !== 'number' ||\n    typeof a !== 'number'\n  ) {\n    return throwError.call(this, 'r, g, b and a must be numbers', cb);\n  }\n\n  if (r < 0 || r > 255) {\n    return throwError.call(this, 'r must be between 0 and 255', cb);\n  }\n\n  if (g < 0 || g > 255) {\n    throwError.call(this, 'g must be between 0 and 255', cb);\n  }\n\n  if (b < 0 || b > 255) {\n    return throwError.call(this, 'b must be between 0 and 255', cb);\n  }\n\n  if (a < 0 || a > 255) {\n    return throwError.call(this, 'a must be between 0 and 255', cb);\n  }\n\n  r = Math.round(r);\n  b = Math.round(b);\n  g = Math.round(g);\n  a = Math.round(a);\n\n  const i =\n    r * Math.pow(256, 3) +\n    g * Math.pow(256, 2) +\n    b * Math.pow(256, 1) +\n    a * Math.pow(256, 0);\n\n  if (isNodePattern(cb)) {\n    cb.call(this, null, i);\n  }\n\n  return i;\n};\n\n/**\n * A static helper method that converts RGBA values to a single integer value\n * @param {number} i a single integer value representing an RGBA colour (e.g. 0xFF0000FF for red)\n * @param {function(Error, Jimp)} cb (optional) A callback for when complete\n * @returns {object} an object with the properties r, g, b and a representing RGBA values\n */\nJimp.intToRGBA = function(i, cb) {\n  if (typeof i !== 'number') {\n    return throwError.call(this, 'i must be a number', cb);\n  }\n\n  const rgba = {};\n\n  rgba.r = Math.floor(i / Math.pow(256, 3));\n  rgba.g = Math.floor((i - rgba.r * Math.pow(256, 3)) / Math.pow(256, 2));\n  rgba.b = Math.floor(\n    (i - rgba.r * Math.pow(256, 3) - rgba.g * Math.pow(256, 2)) /\n      Math.pow(256, 1)\n  );\n  rgba.a = Math.floor(\n    (i -\n      rgba.r * Math.pow(256, 3) -\n      rgba.g * Math.pow(256, 2) -\n      rgba.b * Math.pow(256, 1)) /\n      Math.pow(256, 0)\n  );\n\n  if (isNodePattern(cb)) {\n    cb.call(this, null, rgba);\n  }\n\n  return rgba;\n};\n\n/**\n * Converts a css color (Hex, 8-digit (RGBA) Hex, RGB, RGBA, HSL, HSLA, HSV, HSVA, Named) to a hex number\n * @param {string} cssColor a number\n * @returns {number} a hex number representing a color\n */\nJimp.cssColorToHex = function(cssColor) {\n  cssColor = cssColor || 0; // 0, null, undefined, NaN\n\n  if (typeof cssColor === 'number') return Number(cssColor);\n\n  return parseInt(tinyColor(cssColor).toHex8(), 16);\n};\n\n/**\n * Limits a number to between 0 or 255\n * @param {number} n a number\n * @returns {number} the number limited to between 0 or 255\n */\nJimp.limit255 = function(n) {\n  n = Math.max(n, 0);\n  n = Math.min(n, 255);\n\n  return n;\n};\n\n/**\n * Diffs two images and returns\n * @param {Jimp} img1 a Jimp image to compare\n * @param {Jimp} img2 a Jimp image to compare\n * @param {number} threshold (optional) a number, 0 to 1, the smaller the value the more sensitive the comparison (default: 0.1)\n * @returns {object} an object { percent: percent similar, diff: a Jimp image highlighting differences }\n */\nJimp.diff = function(img1, img2, threshold = 0.1) {\n  if (!(img1 instanceof Jimp) || !(img2 instanceof Jimp))\n    return throwError.call(this, 'img1 and img2 must be an Jimp images');\n\n  const bmp1 = img1.bitmap;\n  const bmp2 = img2.bitmap;\n\n  if (bmp1.width !== bmp2.width || bmp1.height !== bmp2.height) {\n    if (bmp1.width * bmp1.height > bmp2.width * bmp2.height) {\n      // img1 is bigger\n      img1 = img1.cloneQuiet().resize(bmp2.width, bmp2.height);\n    } else {\n      // img2 is bigger (or they are the same in area)\n      img2 = img2.cloneQuiet().resize(bmp1.width, bmp1.height);\n    }\n  }\n\n  if (typeof threshold !== 'number' || threshold < 0 || threshold > 1) {\n    return throwError.call(this, 'threshold must be a number between 0 and 1');\n  }\n\n  const diff = new Jimp(bmp1.width, bmp1.height, 0xffffffff);\n\n  const numDiffPixels = pixelMatch(\n    bmp1.data,\n    bmp2.data,\n    diff.bitmap.data,\n    diff.bitmap.width,\n    diff.bitmap.height,\n    { threshold }\n  );\n\n  return {\n    percent: numDiffPixels / (diff.bitmap.width * diff.bitmap.height),\n    image: diff\n  };\n};\n\n/**\n * Calculates the hamming distance of two images based on their perceptual hash\n * @param {Jimp} img1 a Jimp image to compare\n * @param {Jimp} img2 a Jimp image to compare\n * @returns {number} a number ranging from 0 to 1, 0 means they are believed to be identical\n */\nJimp.distance = function(img1, img2) {\n  const phash = new ImagePHash();\n  const hash1 = phash.getHash(img1);\n  const hash2 = phash.getHash(img2);\n\n  return phash.distance(hash1, hash2);\n};\n\n/**\n * Calculates the hamming distance of two images based on their perceptual hash\n * @param {hash} hash1 a pHash\n * @param {hash} hash2 a pHash\n * @returns {number} a number ranging from 0 to 1, 0 means they are believed to be identical\n */\nJimp.compareHashes = function(hash1, hash2) {\n  const phash = new ImagePHash();\n\n  return phash.distance(hash1, hash2);\n};\n\n/**\n * Compute color difference\n * 0 means no difference, 1 means maximum difference.\n * @param {number} rgba1:    first color to compare.\n * @param {number} rgba2:    second color to compare.\n * Both parameters must be an color object {r:val, g:val, b:val, a:val}\n * Where `a` is optional and `val` is an integer between 0 and 255.\n * @returns {number} float between 0 and 1.\n */\nJimp.colorDiff = function(rgba1, rgba2) {\n  const pow = n => Math.pow(n, 2);\n  const { max } = Math;\n  const maxVal = 255 * 255 * 3;\n\n  if (rgba1.a !== 0 && !rgba1.a) {\n    rgba1.a = 255;\n  }\n\n  if (rgba2.a !== 0 && !rgba2.a) {\n    rgba2.a = 255;\n  }\n\n  return (\n    (max(pow(rgba1.r - rgba2.r), pow(rgba1.r - rgba2.r - rgba1.a + rgba2.a)) +\n      max(pow(rgba1.g - rgba2.g), pow(rgba1.g - rgba2.g - rgba1.a + rgba2.a)) +\n      max(pow(rgba1.b - rgba2.b), pow(rgba1.b - rgba2.b - rgba1.a + rgba2.a))) /\n    maxVal\n  );\n};\n\n/**\n * Helper to create Jimp methods that emit events before and after its execution.\n * @param {string} methodName   The name to be appended to Jimp prototype.\n * @param {string} evName       The event name to be called.\n *                     It will be prefixed by `before-` and emitted when on method call.\n *                     It will be appended by `ed` and emitted after the method run.\n * @param {function} method       A function implementing the method itself.\n * It will also create a quiet version that will not emit events, to not\n * mess the user code with many `changed` event calls. You can call with\n * `methodName + \"Quiet\"`.\n *\n * The emitted event comes with a object parameter to the listener with the\n * `methodName` as one attribute.\n */\nexport function jimpEvMethod(methodName, evName, method) {\n  const evNameBefore = 'before-' + evName;\n  const evNameAfter = evName.replace(/e$/, '') + 'ed';\n\n  Jimp.prototype[methodName] = function(...args) {\n    let wrappedCb;\n    const cb = args[method.length - 1];\n    const jimpInstance = this;\n\n    if (typeof cb === 'function') {\n      wrappedCb = function(...args) {\n        const [err, data] = args;\n\n        if (err) {\n          jimpInstance.emitError(methodName, err);\n        } else {\n          jimpInstance.emitMulti(methodName, evNameAfter, {\n            [methodName]: data\n          });\n        }\n\n        cb.apply(this, args);\n      };\n\n      args[args.length - 1] = wrappedCb;\n    } else {\n      wrappedCb = false;\n    }\n\n    this.emitMulti(methodName, evNameBefore);\n\n    let result;\n\n    try {\n      result = method.apply(this, args);\n\n      if (!wrappedCb) {\n        this.emitMulti(methodName, evNameAfter, {\n          [methodName]: result\n        });\n      }\n    } catch (error) {\n      error.methodName = methodName;\n      this.emitError(methodName, error);\n    }\n\n    return result;\n  };\n\n  Jimp.prototype[methodName + 'Quiet'] = method;\n}\n\n/**\n * Creates a new image that is a clone of this one.\n * @param {function(Error, Jimp)} cb (optional) A callback for when complete\n * @returns the new image\n */\njimpEvMethod('clone', 'clone', function(cb) {\n  const clone = new Jimp(this);\n\n  if (isNodePattern(cb)) {\n    cb.call(clone, null, clone);\n  }\n\n  return clone;\n});\n\n/**\n * Simplify jimpEvMethod call for the common `change` evName.\n * @param {string} methodName name of the method\n * @param {function} method to watch changes for\n */\nexport function jimpEvChange(methodName, method) {\n  jimpEvMethod(methodName, 'change', method);\n}\n\n/**\n * Sets the type of the image (RGB or RGBA) when saving as PNG format (default is RGBA)\n * @param b A Boolean, true to use RGBA or false to use RGB\n * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n * @returns {Jimp} this for chaining of methods\n */\njimpEvChange('background', function(hex, cb) {\n  if (typeof hex !== 'number') {\n    return throwError.call(this, 'hex must be a hexadecimal rgba value', cb);\n  }\n\n  this._background = hex;\n\n  if (isNodePattern(cb)) {\n    cb.call(this, null, this);\n  }\n\n  return this;\n});\n\n/**\n * Scans through a region of the bitmap, calling a function for each pixel.\n * @param {number} x the x coordinate to begin the scan at\n * @param {number} y the y coordinate to begin the scan at\n * @param w the width of the scan region\n * @param h the height of the scan region\n * @param f a function to call on even pixel; the (x, y) position of the pixel\n * and the index of the pixel in the bitmap buffer are passed to the function\n * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n * @returns {Jimp} this for chaining of methods\n */\njimpEvChange('scan', function(x, y, w, h, f, cb) {\n  if (typeof x !== 'number' || typeof y !== 'number') {\n    return throwError.call(this, 'x and y must be numbers', cb);\n  }\n\n  if (typeof w !== 'number' || typeof h !== 'number') {\n    return throwError.call(this, 'w and h must be numbers', cb);\n  }\n\n  if (typeof f !== 'function') {\n    return throwError.call(this, 'f must be a function', cb);\n  }\n\n  const result = scan(this, x, y, w, h, f);\n\n  if (isNodePattern(cb)) {\n    cb.call(this, null, result);\n  }\n\n  return result;\n});\n\nif (process.env.ENVIRONMENT === 'BROWSER') {\n  // For use in a web browser or web worker\n  /* global self */\n  let gl;\n\n  if (typeof window !== 'undefined' && typeof window === 'object') {\n    gl = window;\n  }\n\n  if (typeof self !== 'undefined' && typeof self === 'object') {\n    gl = self;\n  }\n\n  gl.Jimp = Jimp;\n  gl.Buffer = Buffer;\n}\n\nexport { addType } from './utils/mime';\n\nexport default Jimp;\n"],"file":"index.js"}
\ No newline at end of file
diff --git a/node_modules/@jimp/core/es/modules/phash.js b/node_modules/@jimp/core/es/modules/phash.js
index dac128a..100bc1e 100644
--- a/node_modules/@jimp/core/es/modules/phash.js
+++ b/node_modules/@jimp/core/es/modules/phash.js
@@ -1,5 +1,3 @@
-"use strict";
-
 /*
 Copyright (c) 2011 Elliot Shepherd
 
@@ -21,6 +19,7 @@ LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 */
+
 // https://code.google.com/p/ironchef-team21/source/browse/ironchef_team21/src/ImagePHash.java
 
 /*
@@ -28,6 +27,7 @@ THE SOFTWARE.
  * Author: Elliot Shepherd (elliot@jarofworms.com
  * Based On: http://www.hackerfactor.com/blog/index.php?/archives/432-Looks-Like-It.html
  */
+
 function ImagePHash(size, smallerSize) {
   this.size = this.size || size;
   this.smallerSize = this.smallerSize || smallerSize;
@@ -37,20 +37,20 @@ function ImagePHash(size, smallerSize) {
 ImagePHash.prototype.size = 32;
 ImagePHash.prototype.smallerSize = 8;
 
-ImagePHash.prototype.distance = function (s1, s2) {
-  var counter = 0;
+ImagePHash.prototype.distance = function(s1, s2) {
+  let counter = 0;
 
-  for (var k = 0; k < s1.length; k++) {
+  for (let k = 0; k < s1.length; k++) {
     if (s1[k] !== s2[k]) {
       counter++;
     }
   }
 
   return counter / s1.length;
-}; // Returns a 'binary string' (like. 001010111011100010) which is easy to do a hamming distance on.
+};
 
-
-ImagePHash.prototype.getHash = function (img) {
+// Returns a 'binary string' (like. 001010111011100010) which is easy to do a hamming distance on.
+ImagePHash.prototype.getHash = function(img) {
   /* 1. Reduce size.
    * Like Average Hash, pHash starts with a small image.
    * However, the image is larger than 8x8; 32x32 is a good size.
@@ -58,51 +58,50 @@ ImagePHash.prototype.getHash = function (img) {
    * because it is needed to reduce the high frequencies.
    */
   img = img.clone().resize(this.size, this.size);
+
   /* 2. Reduce color.
    * The image is reduced to a grayscale just to further simplify
    * the number of computations.
    */
-
   img.grayscale();
-  var vals = [];
 
-  for (var x = 0; x < img.bitmap.width; x++) {
-    vals[x] = [];
+  const vals = [];
 
-    for (var y = 0; y < img.bitmap.height; y++) {
+  for (let x = 0; x < img.bitmap.width; x++) {
+    vals[x] = [];
+    for (let y = 0; y < img.bitmap.height; y++) {
       vals[x][y] = intToRGBA(img.getPixelColor(x, y)).b;
     }
   }
+
   /* 3. Compute the DCT.
    * The DCT separates the image into a collection of frequencies
    * and scalars. While JPEG uses an 8x8 DCT, this algorithm uses
    * a 32x32 DCT.
    */
+  const dctVals = applyDCT(vals, this.size);
 
-
-  var dctVals = applyDCT(vals, this.size);
   /* 4. Reduce the DCT.
    * This is the magic step. While the DCT is 32x32, just keep the
    * top-left 8x8. Those represent the lowest frequencies in the
    * picture.
    */
-
   /* 5. Compute the average value.
    * Like the Average Hash, compute the mean DCT value (using only
    * the 8x8 DCT low-frequency values and excluding the first term
    * since the DC coefficient can be significantly different from
    * the other values and will throw off the average).
    */
+  let total = 0;
 
-  var total = 0;
-
-  for (var _x = 0; _x < this.smallerSize; _x++) {
-    for (var _y = 0; _y < this.smallerSize; _y++) {
-      total += dctVals[_x][_y];
+  for (let x = 0; x < this.smallerSize; x++) {
+    for (let y = 0; y < this.smallerSize; y++) {
+      total += dctVals[x][y];
     }
   }
 
-  var avg = total / (this.smallerSize * this.smallerSize);
+  const avg = total / (this.smallerSize * this.smallerSize);
+
   /* 6. Further reduce the DCT.
    * This is the magic step. Set the 64 hash bits to 0 or 1
    * depending on whether each of the 64 DCT values is above or
@@ -113,32 +112,42 @@ ImagePHash.prototype.getHash = function (img) {
    * remains the same; this can survive gamma and color histogram
    * adjustments without a problem.
    */
+  let hash = '';
 
-  var hash = '';
-
-  for (var _x2 = 0; _x2 < this.smallerSize; _x2++) {
-    for (var _y2 = 0; _y2 < this.smallerSize; _y2++) {
-      hash += dctVals[_x2][_y2] > avg ? '1' : '0';
+  for (let x = 0; x < this.smallerSize; x++) {
+    for (let y = 0; y < this.smallerSize; y++) {
+      hash += dctVals[x][y] > avg ? '1' : '0';
     }
   }
 
   return hash;
-}; // DCT function stolen from http://stackoverflow.com/questions/4240490/problems-with-dct-and-idct-algorithm-in-java
+};
 
+// DCT function stolen from http://stackoverflow.com/questions/4240490/problems-with-dct-and-idct-algorithm-in-java
 
 function intToRGBA(i) {
-  var rgba = {};
+  const rgba = {};
+
   rgba.r = Math.floor(i / Math.pow(256, 3));
   rgba.g = Math.floor((i - rgba.r * Math.pow(256, 3)) / Math.pow(256, 2));
-  rgba.b = Math.floor((i - rgba.r * Math.pow(256, 3) - rgba.g * Math.pow(256, 2)) / Math.pow(256, 1));
-  rgba.a = Math.floor((i - rgba.r * Math.pow(256, 3) - rgba.g * Math.pow(256, 2) - rgba.b * Math.pow(256, 1)) / Math.pow(256, 0));
+  rgba.b = Math.floor(
+    (i - rgba.r * Math.pow(256, 3) - rgba.g * Math.pow(256, 2)) /
+      Math.pow(256, 1)
+  );
+  rgba.a = Math.floor(
+    (i -
+      rgba.r * Math.pow(256, 3) -
+      rgba.g * Math.pow(256, 2) -
+      rgba.b * Math.pow(256, 1)) /
+      Math.pow(256, 0)
+  );
+
   return rgba;
 }
 
-var c = [];
-
+const c = [];
 function initCoefficients(size) {
-  for (var i = 1; i < size; i++) {
+  for (let i = 1; i < size; i++) {
     c[i] = 1;
   }
 
@@ -146,22 +155,23 @@ function initCoefficients(size) {
 }
 
 function applyDCT(f, size) {
-  var N = size;
-  var F = [];
+  const N = size;
+  const F = [];
 
-  for (var u = 0; u < N; u++) {
+  for (let u = 0; u < N; u++) {
     F[u] = [];
-
-    for (var v = 0; v < N; v++) {
-      var sum = 0;
-
-      for (var i = 0; i < N; i++) {
-        for (var j = 0; j < N; j++) {
-          sum += Math.cos((2 * i + 1) / (2.0 * N) * u * Math.PI) * Math.cos((2 * j + 1) / (2.0 * N) * v * Math.PI) * f[i][j];
+    for (let v = 0; v < N; v++) {
+      let sum = 0;
+      for (let i = 0; i < N; i++) {
+        for (let j = 0; j < N; j++) {
+          sum +=
+            Math.cos(((2 * i + 1) / (2.0 * N)) * u * Math.PI) *
+            Math.cos(((2 * j + 1) / (2.0 * N)) * v * Math.PI) *
+            f[i][j];
         }
       }
 
-      sum *= c[u] * c[v] / 4;
+      sum *= (c[u] * c[v]) / 4;
       F[u][v] = sum;
     }
   }
@@ -170,4 +180,3 @@ function applyDCT(f, size) {
 }
 
 module.exports = ImagePHash;
-//# sourceMappingURL=phash.js.map
\ No newline at end of file
diff --git a/node_modules/@jimp/core/es/modules/phash.js.map b/node_modules/@jimp/core/es/modules/phash.js.map
deleted file mode 100644
index 5556e31..0000000
--- a/node_modules/@jimp/core/es/modules/phash.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"sources":["../../src/modules/phash.js"],"names":["ImagePHash","size","smallerSize","initCoefficients","prototype","distance","s1","s2","counter","k","length","getHash","img","clone","resize","grayscale","vals","x","bitmap","width","y","height","intToRGBA","getPixelColor","b","dctVals","applyDCT","total","avg","hash","i","rgba","r","Math","floor","pow","g","a","c","sqrt","f","N","F","u","v","sum","j","cos","PI","module","exports"],"mappings":"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","sourcesContent":["/*\nCopyright (c) 2011 Elliot Shepherd\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\n// https://code.google.com/p/ironchef-team21/source/browse/ironchef_team21/src/ImagePHash.java\n\n/*\n * pHash-like image hash.\n * Author: Elliot Shepherd (elliot@jarofworms.com\n * Based On: http://www.hackerfactor.com/blog/index.php?/archives/432-Looks-Like-It.html\n */\n\nfunction ImagePHash(size, smallerSize) {\n  this.size = this.size || size;\n  this.smallerSize = this.smallerSize || smallerSize;\n  initCoefficients(this.size);\n}\n\nImagePHash.prototype.size = 32;\nImagePHash.prototype.smallerSize = 8;\n\nImagePHash.prototype.distance = function(s1, s2) {\n  let counter = 0;\n\n  for (let k = 0; k < s1.length; k++) {\n    if (s1[k] !== s2[k]) {\n      counter++;\n    }\n  }\n\n  return counter / s1.length;\n};\n\n// Returns a 'binary string' (like. 001010111011100010) which is easy to do a hamming distance on.\nImagePHash.prototype.getHash = function(img) {\n  /* 1. Reduce size.\n   * Like Average Hash, pHash starts with a small image.\n   * However, the image is larger than 8x8; 32x32 is a good size.\n   * This is really done to simplify the DCT computation and not\n   * because it is needed to reduce the high frequencies.\n   */\n  img = img.clone().resize(this.size, this.size);\n\n  /* 2. Reduce color.\n   * The image is reduced to a grayscale just to further simplify\n   * the number of computations.\n   */\n  img.grayscale();\n\n  const vals = [];\n\n  for (let x = 0; x < img.bitmap.width; x++) {\n    vals[x] = [];\n    for (let y = 0; y < img.bitmap.height; y++) {\n      vals[x][y] = intToRGBA(img.getPixelColor(x, y)).b;\n    }\n  }\n\n  /* 3. Compute the DCT.\n   * The DCT separates the image into a collection of frequencies\n   * and scalars. While JPEG uses an 8x8 DCT, this algorithm uses\n   * a 32x32 DCT.\n   */\n  const dctVals = applyDCT(vals, this.size);\n\n  /* 4. Reduce the DCT.\n   * This is the magic step. While the DCT is 32x32, just keep the\n   * top-left 8x8. Those represent the lowest frequencies in the\n   * picture.\n   */\n  /* 5. Compute the average value.\n   * Like the Average Hash, compute the mean DCT value (using only\n   * the 8x8 DCT low-frequency values and excluding the first term\n   * since the DC coefficient can be significantly different from\n   * the other values and will throw off the average).\n   */\n  let total = 0;\n\n  for (let x = 0; x < this.smallerSize; x++) {\n    for (let y = 0; y < this.smallerSize; y++) {\n      total += dctVals[x][y];\n    }\n  }\n\n  const avg = total / (this.smallerSize * this.smallerSize);\n\n  /* 6. Further reduce the DCT.\n   * This is the magic step. Set the 64 hash bits to 0 or 1\n   * depending on whether each of the 64 DCT values is above or\n   * below the average value. The result doesn't tell us the\n   * actual low frequencies; it just tells us the very-rough\n   * relative scale of the frequencies to the mean. The result\n   * will not vary as long as the overall structure of the image\n   * remains the same; this can survive gamma and color histogram\n   * adjustments without a problem.\n   */\n  let hash = '';\n\n  for (let x = 0; x < this.smallerSize; x++) {\n    for (let y = 0; y < this.smallerSize; y++) {\n      hash += dctVals[x][y] > avg ? '1' : '0';\n    }\n  }\n\n  return hash;\n};\n\n// DCT function stolen from http://stackoverflow.com/questions/4240490/problems-with-dct-and-idct-algorithm-in-java\n\nfunction intToRGBA(i) {\n  const rgba = {};\n\n  rgba.r = Math.floor(i / Math.pow(256, 3));\n  rgba.g = Math.floor((i - rgba.r * Math.pow(256, 3)) / Math.pow(256, 2));\n  rgba.b = Math.floor(\n    (i - rgba.r * Math.pow(256, 3) - rgba.g * Math.pow(256, 2)) /\n      Math.pow(256, 1)\n  );\n  rgba.a = Math.floor(\n    (i -\n      rgba.r * Math.pow(256, 3) -\n      rgba.g * Math.pow(256, 2) -\n      rgba.b * Math.pow(256, 1)) /\n      Math.pow(256, 0)\n  );\n\n  return rgba;\n}\n\nconst c = [];\nfunction initCoefficients(size) {\n  for (let i = 1; i < size; i++) {\n    c[i] = 1;\n  }\n\n  c[0] = 1 / Math.sqrt(2.0);\n}\n\nfunction applyDCT(f, size) {\n  const N = size;\n  const F = [];\n\n  for (let u = 0; u < N; u++) {\n    F[u] = [];\n    for (let v = 0; v < N; v++) {\n      let sum = 0;\n      for (let i = 0; i < N; i++) {\n        for (let j = 0; j < N; j++) {\n          sum +=\n            Math.cos(((2 * i + 1) / (2.0 * N)) * u * Math.PI) *\n            Math.cos(((2 * j + 1) / (2.0 * N)) * v * Math.PI) *\n            f[i][j];\n        }\n      }\n\n      sum *= (c[u] * c[v]) / 4;\n      F[u][v] = sum;\n    }\n  }\n\n  return F;\n}\n\nmodule.exports = ImagePHash;\n"],"file":"phash.js"}
\ No newline at end of file
diff --git a/node_modules/@jimp/core/es/request.js b/node_modules/@jimp/core/es/request.js
index 4b211f7..4f35df6 100644
--- a/node_modules/@jimp/core/es/request.js
+++ b/node_modules/@jimp/core/es/request.js
@@ -1,55 +1,30 @@
-"use strict";
-
-var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
-
-var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
-
-var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));
-
-function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }
-
-function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
-
 /* global XMLHttpRequest */
-if (process.browser || process.env.ENVIRONMENT === 'BROWSER' || typeof process.versions.electron !== 'undefined' && process.type === 'renderer' && typeof XMLHttpRequest === 'function') {
-  // If we run into a browser or the electron renderer process,
-  // use XHR method instead of Request node module.
-  module.exports = function (options, cb) {
-    var xhr = new XMLHttpRequest();
-    xhr.open('GET', options.url, true);
-    xhr.responseType = 'arraybuffer';
-    xhr.addEventListener('load', function () {
-      if (xhr.status < 400) {
-        try {
-          var data = Buffer.from(this.response);
-          cb(null, xhr, data);
-        } catch (error) {
-          return cb(new Error('Response is not a buffer for url ' + options.url + '. Error: ' + error.message));
-        }
-      } else {
-        cb(new Error('HTTP Status ' + xhr.status + ' for url ' + options.url));
-      }
-    });
-    xhr.addEventListener('error', function (e) {
-      cb(e);
-    });
-    xhr.send();
-  };
-} else {
-  module.exports = function (_ref, cb) {
-    var options = (0, _extends2["default"])({}, _ref);
-
-    var p = require('phin');
 
-    p(_objectSpread({
-      compression: true
-    }, options), function (err, res) {
-      if (err === null) {
-        cb(null, res, res.body);
-      } else {
-        cb(err);
+export default function(options, cb) {
+  const xhr = new XMLHttpRequest();
+  xhr.open('GET', options.url, true);
+  xhr.responseType = 'arraybuffer';
+  xhr.addEventListener('load', function() {
+    if (xhr.status < 400) {
+      try {
+        const data = Buffer.from(this.response);
+        cb(null, xhr, data);
+      } catch (error) {
+        return cb(
+          new Error(
+            'Response is not a buffer for url ' +
+              options.url +
+              '. Error: ' +
+              error.message
+          )
+        );
       }
-    });
-  };
-}
-//# sourceMappingURL=request.js.map
\ No newline at end of file
+    } else {
+      cb(new Error('HTTP Status ' + xhr.status + ' for url ' + options.url));
+    }
+  });
+  xhr.addEventListener('error', e => {
+    cb(e);
+  });
+  xhr.send();
+};
\ No newline at end of file
diff --git a/node_modules/@jimp/core/es/request.js.map b/node_modules/@jimp/core/es/request.js.map
deleted file mode 100644
index 04a1d46..0000000
--- a/node_modules/@jimp/core/es/request.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"sources":["../src/request.js"],"names":["process","browser","env","ENVIRONMENT","versions","electron","type","XMLHttpRequest","module","exports","options","cb","xhr","open","url","responseType","addEventListener","status","data","Buffer","from","response","error","Error","message","e","send","p","require","compression","err","res","body"],"mappings":";;;;;;;;;;;;AAAA;AAEA,IACEA,OAAO,CAACC,OAAR,IACAD,OAAO,CAACE,GAAR,CAAYC,WAAZ,KAA4B,SAD5B,IAEC,OAAOH,OAAO,CAACI,QAAR,CAAiBC,QAAxB,KAAqC,WAArC,IACCL,OAAO,CAACM,IAAR,KAAiB,UADlB,IAEC,OAAOC,cAAP,KAA0B,UAL9B,EAME;AACA;AACA;AAEAC,EAAAA,MAAM,CAACC,OAAP,GAAiB,UAASC,OAAT,EAAkBC,EAAlB,EAAsB;AACrC,QAAMC,GAAG,GAAG,IAAIL,cAAJ,EAAZ;AACAK,IAAAA,GAAG,CAACC,IAAJ,CAAS,KAAT,EAAgBH,OAAO,CAACI,GAAxB,EAA6B,IAA7B;AACAF,IAAAA,GAAG,CAACG,YAAJ,GAAmB,aAAnB;AACAH,IAAAA,GAAG,CAACI,gBAAJ,CAAqB,MAArB,EAA6B,YAAW;AACtC,UAAIJ,GAAG,CAACK,MAAJ,GAAa,GAAjB,EAAsB;AACpB,YAAI;AACF,cAAMC,IAAI,GAAGC,MAAM,CAACC,IAAP,CAAY,KAAKC,QAAjB,CAAb;AACAV,UAAAA,EAAE,CAAC,IAAD,EAAOC,GAAP,EAAYM,IAAZ,CAAF;AACD,SAHD,CAGE,OAAOI,KAAP,EAAc;AACd,iBAAOX,EAAE,CACP,IAAIY,KAAJ,CACE,sCACEb,OAAO,CAACI,GADV,GAEE,WAFF,GAGEQ,KAAK,CAACE,OAJV,CADO,CAAT;AAQD;AACF,OAdD,MAcO;AACLb,QAAAA,EAAE,CAAC,IAAIY,KAAJ,CAAU,iBAAiBX,GAAG,CAACK,MAArB,GAA8B,WAA9B,GAA4CP,OAAO,CAACI,GAA9D,CAAD,CAAF;AACD;AACF,KAlBD;AAmBAF,IAAAA,GAAG,CAACI,gBAAJ,CAAqB,OAArB,EAA8B,UAAAS,CAAC,EAAI;AACjCd,MAAAA,EAAE,CAACc,CAAD,CAAF;AACD,KAFD;AAGAb,IAAAA,GAAG,CAACc,IAAJ;AACD,GA3BD;AA4BD,CAtCD,MAsCO;AACLlB,EAAAA,MAAM,CAACC,OAAP,GAAiB,gBAAyBE,EAAzB,EAA6B;AAAA,QAAfD,OAAe;;AAC5C,QAAMiB,CAAC,GAAGC,OAAO,CAAC,MAAD,CAAjB;;AAEAD,IAAAA,CAAC;AAAGE,MAAAA,WAAW,EAAE;AAAhB,OAAyBnB,OAAzB,GAAoC,UAACoB,GAAD,EAAMC,GAAN,EAAc;AACjD,UAAID,GAAG,KAAK,IAAZ,EAAkB;AAChBnB,QAAAA,EAAE,CAAC,IAAD,EAAOoB,GAAP,EAAYA,GAAG,CAACC,IAAhB,CAAF;AACD,OAFD,MAEO;AACLrB,QAAAA,EAAE,CAACmB,GAAD,CAAF;AACD;AACF,KANA,CAAD;AAOD,GAVD;AAWD","sourcesContent":["/* global XMLHttpRequest */\n\nif (\n  process.browser ||\n  process.env.ENVIRONMENT === 'BROWSER' ||\n  (typeof process.versions.electron !== 'undefined' &&\n    process.type === 'renderer' &&\n    typeof XMLHttpRequest === 'function')\n) {\n  // If we run into a browser or the electron renderer process,\n  // use XHR method instead of Request node module.\n\n  module.exports = function(options, cb) {\n    const xhr = new XMLHttpRequest();\n    xhr.open('GET', options.url, true);\n    xhr.responseType = 'arraybuffer';\n    xhr.addEventListener('load', function() {\n      if (xhr.status < 400) {\n        try {\n          const data = Buffer.from(this.response);\n          cb(null, xhr, data);\n        } catch (error) {\n          return cb(\n            new Error(\n              'Response is not a buffer for url ' +\n                options.url +\n                '. Error: ' +\n                error.message\n            )\n          );\n        }\n      } else {\n        cb(new Error('HTTP Status ' + xhr.status + ' for url ' + options.url));\n      }\n    });\n    xhr.addEventListener('error', e => {\n      cb(e);\n    });\n    xhr.send();\n  };\n} else {\n  module.exports = function({ ...options }, cb) {\n    const p = require('phin');\n\n    p({ compression: true, ...options }, (err, res) => {\n      if (err === null) {\n        cb(null, res, res.body);\n      } else {\n        cb(err);\n      }\n    });\n  };\n}\n"],"file":"request.js"}
\ No newline at end of file
diff --git a/node_modules/@jimp/core/es/utils/image-bitmap.js b/node_modules/@jimp/core/es/utils/image-bitmap.js
index 4beabbe..875079e 100644
--- a/node_modules/@jimp/core/es/utils/image-bitmap.js
+++ b/node_modules/@jimp/core/es/utils/image-bitmap.js
@@ -1,32 +1,14 @@
-"use strict";
+import fileType from 'file-type';
 
-var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");
+import EXIFParser from 'exif-parser';
+import { throwError } from '@jimp/utils';
 
-var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
-
-Object.defineProperty(exports, "__esModule", {
-  value: true
-});
-exports.parseBitmap = parseBitmap;
-exports.getBuffer = getBuffer;
-exports.getBufferAsync = getBufferAsync;
-
-var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
-
-var _fileType = _interopRequireDefault(require("file-type"));
-
-var _exifParser = _interopRequireDefault(require("exif-parser"));
-
-var _utils = require("@jimp/utils");
-
-var constants = _interopRequireWildcard(require("../constants"));
-
-var MIME = _interopRequireWildcard(require("./mime"));
-
-var _promisify = _interopRequireDefault(require("./promisify"));
+import * as constants from '../constants';
+import * as MIME from './mime';
+import promisify from './promisify';
 
 function getMIMEFromBuffer(buffer, path) {
-  var fileTypeFromBuffer = (0, _fileType["default"])(buffer);
+  const fileTypeFromBuffer = fileType(buffer);
 
   if (fileTypeFromBuffer) {
     // If fileType returns something for buffer, then return the mime given
@@ -41,6 +23,7 @@ function getMIMEFromBuffer(buffer, path) {
 
   return null;
 }
+
 /*
  * Obtains image orientation from EXIF metadata.
  *
@@ -48,11 +31,10 @@ function getMIMEFromBuffer(buffer, path) {
  * @returns {number} a number 1-8 representing EXIF orientation,
  *          in particular 1 if orientation tag is missing
  */
-
-
 function getExifOrientation(img) {
-  return img._exif && img._exif.tags && img._exif.tags.Orientation || 1;
+  return (img._exif && img._exif.tags && img._exif.tags.Orientation) || 1;
 }
+
 /**
  * Returns a function which translates EXIF-rotated coordinates into
  * non-rotated ones.
@@ -62,57 +44,47 @@ function getExifOrientation(img) {
  * @param img {Jimp} a Jimp image object
  * @returns {function} transformation function for transformBitmap().
  */
-
-
 function getExifOrientationTransformation(img) {
-  var w = img.getWidth();
-  var h = img.getHeight();
+  const w = img.getWidth();
+  const h = img.getHeight();
 
   switch (getExifOrientation(img)) {
-    case 1:
-      // Horizontal (normal)
+    case 1: // Horizontal (normal)
       // does not need to be supported here
       return null;
 
-    case 2:
-      // Mirror horizontal
-      return function (x, y) {
+    case 2: // Mirror horizontal
+      return function(x, y) {
         return [w - x - 1, y];
       };
 
-    case 3:
-      // Rotate 180
-      return function (x, y) {
+    case 3: // Rotate 180
+      return function(x, y) {
         return [w - x - 1, h - y - 1];
       };
 
-    case 4:
-      // Mirror vertical
-      return function (x, y) {
+    case 4: // Mirror vertical
+      return function(x, y) {
         return [x, h - y - 1];
       };
 
-    case 5:
-      // Mirror horizontal and rotate 270 CW
-      return function (x, y) {
+    case 5: // Mirror horizontal and rotate 270 CW
+      return function(x, y) {
         return [y, x];
       };
 
-    case 6:
-      // Rotate 90 CW
-      return function (x, y) {
+    case 6: // Rotate 90 CW
+      return function(x, y) {
         return [y, h - x - 1];
       };
 
-    case 7:
-      // Mirror horizontal and rotate 90 CW
-      return function (x, y) {
+    case 7: // Mirror horizontal and rotate 90 CW
+      return function(x, y) {
         return [w - y - 1, h - x - 1];
       };
 
-    case 8:
-      // Rotate 270 CW
-      return function (x, y) {
+    case 8: // Rotate 270 CW
+      return function(x, y) {
         return [w - y - 1, x];
       };
 
@@ -120,6 +92,7 @@ function getExifOrientationTransformation(img) {
       return null;
   }
 }
+
 /*
  * Transforms bitmap in place (moves pixels around) according to given
  * transformation function.
@@ -134,28 +107,22 @@ function getExifOrientationTransformation(img) {
  *        the source bitmap, i.e. has following form:
  *        `function(new_x, new_y) { return [src_x, src_y] }`.
  */
-
-
 function transformBitmap(img, width, height, transformation) {
   // Underscore-prefixed values are related to the source bitmap
   // Their counterparts with no prefix are related to the target bitmap
-  var _data = img.bitmap.data;
-  var _width = img.bitmap.width;
-  var data = Buffer.alloc(_data.length);
+  const _data = img.bitmap.data;
+  const _width = img.bitmap.width;
 
-  for (var x = 0; x < width; x++) {
-    for (var y = 0; y < height; y++) {
-      var _transformation = transformation(x, y),
-          _transformation2 = (0, _slicedToArray2["default"])(_transformation, 2),
-          _x = _transformation2[0],
-          _y = _transformation2[1];
+  const data = Buffer.alloc(_data.length);
 
-      var idx = width * y + x << 2;
+  for (let x = 0; x < width; x++) {
+    for (let y = 0; y < height; y++) {
+      const [_x, _y] = transformation(x, y);
 
-      var _idx = _width * _y + _x << 2;
-
-      var pixel = _data.readUInt32BE(_idx);
+      const idx = (width * y + x) << 2;
+      const _idx = (_width * _y + _x) << 2;
 
+      const pixel = _data.readUInt32BE(_idx);
       data.writeUInt32BE(pixel, idx);
     }
   }
@@ -164,24 +131,26 @@ function transformBitmap(img, width, height, transformation) {
   img.bitmap.width = width;
   img.bitmap.height = height;
 }
+
 /*
  * Automagically rotates an image based on its EXIF data (if present).
  * @param img {Jimp} a Jimp image object
  */
-
-
 function exifRotate(img) {
   if (getExifOrientation(img) < 2) return;
-  var transformation = getExifOrientationTransformation(img);
-  var swapDimensions = getExifOrientation(img) > 4;
-  var newWidth = swapDimensions ? img.bitmap.height : img.bitmap.width;
-  var newHeight = swapDimensions ? img.bitmap.width : img.bitmap.height;
-  transformBitmap(img, newWidth, newHeight, transformation);
-} // parses a bitmap from the constructor to the JIMP bitmap property
 
+  const transformation = getExifOrientationTransformation(img);
+  const swapDimensions = getExifOrientation(img) > 4;
 
-function parseBitmap(data, path, cb) {
-  var mime = getMIMEFromBuffer(data, path);
+  const newWidth = swapDimensions ? img.bitmap.height : img.bitmap.width;
+  const newHeight = swapDimensions ? img.bitmap.width : img.bitmap.height;
+
+  transformBitmap(img, newWidth, newHeight, transformation);
+}
+
+// parses a bitmap from the constructor to the JIMP bitmap property
+export function parseBitmap(data, path, cb) {
+  const mime = getMIMEFromBuffer(data, path);
 
   if (typeof mime !== 'string') {
     return cb(new Error('Could not find MIME for Buffer <' + path + '>'));
@@ -190,51 +159,55 @@ function parseBitmap(data, path, cb) {
   this._originalMime = mime.toLowerCase();
 
   try {
-    var _mime = this.getMIME();
+    const mime = this.getMIME();
 
-    if (this.constructor.decoders[_mime]) {
-      this.bitmap = this.constructor.decoders[_mime](data);
+    if (this.constructor.decoders[mime]) {
+      this.bitmap = this.constructor.decoders[mime](data);
     } else {
-      return _utils.throwError.call(this, 'Unsupported MIME type: ' + _mime, cb);
+      return throwError.call(this, 'Unsupported MIME type: ' + mime, cb);
     }
   } catch (error) {
     return cb.call(this, error, this);
   }
 
   try {
-    this._exif = _exifParser["default"].create(data).parse();
+    this._exif = EXIFParser.create(data).parse();
     exifRotate(this); // EXIF data
   } catch (error) {
     /* meh */
   }
 
   cb.call(this, null, this);
+
   return this;
 }
 
 function compositeBitmapOverBackground(Jimp, image) {
-  return new Jimp(image.bitmap.width, image.bitmap.height, image._background).composite(image, 0, 0).bitmap;
+  return new Jimp(
+    image.bitmap.width,
+    image.bitmap.height,
+    image._background
+  ).composite(image, 0, 0).bitmap;
 }
+
 /**
  * Converts the image to a buffer
  * @param {string} mime the mime type of the image buffer to be created
  * @param {function(Error, Jimp)} cb a Node-style function to call with the buffer as the second argument
  * @returns {Jimp} this for chaining of methods
  */
-
-
-function getBuffer(mime, cb) {
+export function getBuffer(mime, cb) {
   if (mime === constants.AUTO) {
     // allow auto MIME detection
     mime = this.getMIME();
   }
 
   if (typeof mime !== 'string') {
-    return _utils.throwError.call(this, 'mime must be a string', cb);
+    return throwError.call(this, 'mime must be a string', cb);
   }
 
   if (typeof cb !== 'function') {
-    return _utils.throwError.call(this, 'cb must be a function', cb);
+    return throwError.call(this, 'cb must be a function', cb);
   }
 
   mime = mime.toLowerCase();
@@ -244,11 +217,14 @@ function getBuffer(mime, cb) {
   } else {
     // when format doesn't support alpha
     // composite onto a new image so that the background shows through alpha channels
-    this.bitmap.data = compositeBitmapOverBackground(this.constructor, this).data;
+    this.bitmap.data = compositeBitmapOverBackground(
+      this.constructor,
+      this
+    ).data;
   }
 
   if (this.constructor.encoders[mime]) {
-    var buffer = this.constructor.encoders[mime](this);
+    const buffer = this.constructor.encoders[mime](this);
     cb.call(this, null, buffer);
   } else {
     cb.call(this, 'Unsupported MIME type: ' + mime);
@@ -257,7 +233,6 @@ function getBuffer(mime, cb) {
   return this;
 }
 
-function getBufferAsync(mime) {
-  return (0, _promisify["default"])(getBuffer, this, mime);
+export function getBufferAsync(mime) {
+  return promisify(getBuffer, this, mime);
 }
-//# sourceMappingURL=image-bitmap.js.map
\ No newline at end of file
diff --git a/node_modules/@jimp/core/es/utils/image-bitmap.js.map b/node_modules/@jimp/core/es/utils/image-bitmap.js.map
deleted file mode 100644
index dc78d9d..0000000
--- a/node_modules/@jimp/core/es/utils/image-bitmap.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"sources":["../../src/utils/image-bitmap.js"],"names":["getMIMEFromBuffer","buffer","path","fileTypeFromBuffer","mime","MIME","getType","getExifOrientation","img","_exif","tags","Orientation","getExifOrientationTransformation","w","getWidth","h","getHeight","x","y","transformBitmap","width","height","transformation","_data","bitmap","data","_width","Buffer","alloc","length","_x","_y","idx","_idx","pixel","readUInt32BE","writeUInt32BE","exifRotate","swapDimensions","newWidth","newHeight","parseBitmap","cb","Error","_originalMime","toLowerCase","getMIME","constructor","decoders","throwError","call","error","EXIFParser","create","parse","compositeBitmapOverBackground","Jimp","image","_background","composite","getBuffer","constants","AUTO","_rgba","hasAlpha","from","encoders","getBufferAsync"],"mappings":"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","sourcesContent":["import fileType from 'file-type';\n\nimport EXIFParser from 'exif-parser';\nimport { throwError } from '@jimp/utils';\n\nimport * as constants from '../constants';\nimport * as MIME from './mime';\nimport promisify from './promisify';\n\nfunction getMIMEFromBuffer(buffer, path) {\n  const fileTypeFromBuffer = fileType(buffer);\n\n  if (fileTypeFromBuffer) {\n    // If fileType returns something for buffer, then return the mime given\n    return fileTypeFromBuffer.mime;\n  }\n\n  if (path) {\n    // If a path is supplied, and fileType yields no results, then retry with MIME\n    // Path can be either a file path or a url\n    return MIME.getType(path);\n  }\n\n  return null;\n}\n\n/*\n * Obtains image orientation from EXIF metadata.\n *\n * @param img {Jimp} a Jimp image object\n * @returns {number} a number 1-8 representing EXIF orientation,\n *          in particular 1 if orientation tag is missing\n */\nfunction getExifOrientation(img) {\n  return (img._exif && img._exif.tags && img._exif.tags.Orientation) || 1;\n}\n\n/**\n * Returns a function which translates EXIF-rotated coordinates into\n * non-rotated ones.\n *\n * Transformation reference: http://sylvana.net/jpegcrop/exif_orientation.html.\n *\n * @param img {Jimp} a Jimp image object\n * @returns {function} transformation function for transformBitmap().\n */\nfunction getExifOrientationTransformation(img) {\n  const w = img.getWidth();\n  const h = img.getHeight();\n\n  switch (getExifOrientation(img)) {\n    case 1: // Horizontal (normal)\n      // does not need to be supported here\n      return null;\n\n    case 2: // Mirror horizontal\n      return function(x, y) {\n        return [w - x - 1, y];\n      };\n\n    case 3: // Rotate 180\n      return function(x, y) {\n        return [w - x - 1, h - y - 1];\n      };\n\n    case 4: // Mirror vertical\n      return function(x, y) {\n        return [x, h - y - 1];\n      };\n\n    case 5: // Mirror horizontal and rotate 270 CW\n      return function(x, y) {\n        return [y, x];\n      };\n\n    case 6: // Rotate 90 CW\n      return function(x, y) {\n        return [y, h - x - 1];\n      };\n\n    case 7: // Mirror horizontal and rotate 90 CW\n      return function(x, y) {\n        return [w - y - 1, h - x - 1];\n      };\n\n    case 8: // Rotate 270 CW\n      return function(x, y) {\n        return [w - y - 1, x];\n      };\n\n    default:\n      return null;\n  }\n}\n\n/*\n * Transforms bitmap in place (moves pixels around) according to given\n * transformation function.\n *\n * @param img {Jimp} a Jimp image object, which bitmap is supposed to\n *        be transformed\n * @param width {number} bitmap width after the transformation\n * @param height {number} bitmap height after the transformation\n * @param transformation {function} transformation function which defines pixel\n *        mapping between new and source bitmap. It takes a pair of coordinates\n *        in the target, and returns a respective pair of coordinates in\n *        the source bitmap, i.e. has following form:\n *        `function(new_x, new_y) { return [src_x, src_y] }`.\n */\nfunction transformBitmap(img, width, height, transformation) {\n  // Underscore-prefixed values are related to the source bitmap\n  // Their counterparts with no prefix are related to the target bitmap\n  const _data = img.bitmap.data;\n  const _width = img.bitmap.width;\n\n  const data = Buffer.alloc(_data.length);\n\n  for (let x = 0; x < width; x++) {\n    for (let y = 0; y < height; y++) {\n      const [_x, _y] = transformation(x, y);\n\n      const idx = (width * y + x) << 2;\n      const _idx = (_width * _y + _x) << 2;\n\n      const pixel = _data.readUInt32BE(_idx);\n      data.writeUInt32BE(pixel, idx);\n    }\n  }\n\n  img.bitmap.data = data;\n  img.bitmap.width = width;\n  img.bitmap.height = height;\n}\n\n/*\n * Automagically rotates an image based on its EXIF data (if present).\n * @param img {Jimp} a Jimp image object\n */\nfunction exifRotate(img) {\n  if (getExifOrientation(img) < 2) return;\n\n  const transformation = getExifOrientationTransformation(img);\n  const swapDimensions = getExifOrientation(img) > 4;\n\n  const newWidth = swapDimensions ? img.bitmap.height : img.bitmap.width;\n  const newHeight = swapDimensions ? img.bitmap.width : img.bitmap.height;\n\n  transformBitmap(img, newWidth, newHeight, transformation);\n}\n\n// parses a bitmap from the constructor to the JIMP bitmap property\nexport function parseBitmap(data, path, cb) {\n  const mime = getMIMEFromBuffer(data, path);\n\n  if (typeof mime !== 'string') {\n    return cb(new Error('Could not find MIME for Buffer <' + path + '>'));\n  }\n\n  this._originalMime = mime.toLowerCase();\n\n  try {\n    const mime = this.getMIME();\n\n    if (this.constructor.decoders[mime]) {\n      this.bitmap = this.constructor.decoders[mime](data);\n    } else {\n      return throwError.call(this, 'Unsupported MIME type: ' + mime, cb);\n    }\n  } catch (error) {\n    return cb.call(this, error, this);\n  }\n\n  try {\n    this._exif = EXIFParser.create(data).parse();\n    exifRotate(this); // EXIF data\n  } catch (error) {\n    /* meh */\n  }\n\n  cb.call(this, null, this);\n\n  return this;\n}\n\nfunction compositeBitmapOverBackground(Jimp, image) {\n  return new Jimp(\n    image.bitmap.width,\n    image.bitmap.height,\n    image._background\n  ).composite(image, 0, 0).bitmap;\n}\n\n/**\n * Converts the image to a buffer\n * @param {string} mime the mime type of the image buffer to be created\n * @param {function(Error, Jimp)} cb a Node-style function to call with the buffer as the second argument\n * @returns {Jimp} this for chaining of methods\n */\nexport function getBuffer(mime, cb) {\n  if (mime === constants.AUTO) {\n    // allow auto MIME detection\n    mime = this.getMIME();\n  }\n\n  if (typeof mime !== 'string') {\n    return throwError.call(this, 'mime must be a string', cb);\n  }\n\n  if (typeof cb !== 'function') {\n    return throwError.call(this, 'cb must be a function', cb);\n  }\n\n  mime = mime.toLowerCase();\n\n  if (this._rgba && this.constructor.hasAlpha[mime]) {\n    this.bitmap.data = Buffer.from(this.bitmap.data);\n  } else {\n    // when format doesn't support alpha\n    // composite onto a new image so that the background shows through alpha channels\n    this.bitmap.data = compositeBitmapOverBackground(\n      this.constructor,\n      this\n    ).data;\n  }\n\n  if (this.constructor.encoders[mime]) {\n    const buffer = this.constructor.encoders[mime](this);\n    cb.call(this, null, buffer);\n  } else {\n    cb.call(this, 'Unsupported MIME type: ' + mime);\n  }\n\n  return this;\n}\n\nexport function getBufferAsync(mime) {\n  return promisify(getBuffer, this, mime);\n}\n"],"file":"image-bitmap.js"}
\ No newline at end of file
diff --git a/node_modules/@jimp/core/es/utils/mime.js b/node_modules/@jimp/core/es/utils/mime.js
index 9e48085..608749e 100644
--- a/node_modules/@jimp/core/es/utils/mime.js
+++ b/node_modules/@jimp/core/es/utils/mime.js
@@ -1,47 +1,28 @@
-"use strict";
+const mimeTypes = {};
 
-Object.defineProperty(exports, "__esModule", {
-  value: true
-});
-exports.getExtension = exports.getType = exports.addType = void 0;
-var mimeTypes = {};
+const findType = extension =>
+  Object.entries(mimeTypes).find(type => type[1].includes(extension)) || [];
 
-var findType = function findType(extension) {
-  return Object.entries(mimeTypes).find(function (type) {
-    return type[1].includes(extension);
-  }) || [];
-};
-
-var addType = function addType(mime, extensions) {
+export const addType = (mime, extensions) => {
   mimeTypes[mime] = extensions;
 };
+
 /**
  * Lookup a mime type based on extension
  * @param {string} path path to find extension for
  * @returns {string} mime found mime type
  */
+export const getType = path => {
+  const pathParts = path.split('/').slice(-1);
+  const extension = pathParts[pathParts.length - 1].split('.').pop();
+  const type = findType(extension);
 
-
-exports.addType = addType;
-
-var getType = function getType(path) {
-  var pathParts = path.split('/').slice(-1);
-  var extension = pathParts[pathParts.length - 1].split('.').pop();
-  var type = findType(extension);
   return type[0];
 };
+
 /**
  * Return file extension associated with a mime type
  * @param {string} type mime type to look up
  * @returns {string} extension file extension
  */
-
-
-exports.getType = getType;
-
-var getExtension = function getExtension(type) {
-  return (mimeTypes[type.toLowerCase()] || [])[0];
-};
-
-exports.getExtension = getExtension;
-//# sourceMappingURL=mime.js.map
\ No newline at end of file
+export const getExtension = type => (mimeTypes[type.toLowerCase()] || [])[0];
diff --git a/node_modules/@jimp/core/es/utils/mime.js.map b/node_modules/@jimp/core/es/utils/mime.js.map
deleted file mode 100644
index 5a3501b..0000000
--- a/node_modules/@jimp/core/es/utils/mime.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"sources":["../../src/utils/mime.js"],"names":["mimeTypes","findType","extension","Object","entries","find","type","includes","addType","mime","extensions","getType","path","pathParts","split","slice","length","pop","getExtension","toLowerCase"],"mappings":";;;;;;AAAA,IAAMA,SAAS,GAAG,EAAlB;;AAEA,IAAMC,QAAQ,GAAG,SAAXA,QAAW,CAAAC,SAAS;AAAA,SACxBC,MAAM,CAACC,OAAP,CAAeJ,SAAf,EAA0BK,IAA1B,CAA+B,UAAAC,IAAI;AAAA,WAAIA,IAAI,CAAC,CAAD,CAAJ,CAAQC,QAAR,CAAiBL,SAAjB,CAAJ;AAAA,GAAnC,KAAuE,EAD/C;AAAA,CAA1B;;AAGO,IAAMM,OAAO,GAAG,SAAVA,OAAU,CAACC,IAAD,EAAOC,UAAP,EAAsB;AAC3CV,EAAAA,SAAS,CAACS,IAAD,CAAT,GAAkBC,UAAlB;AACD,CAFM;AAIP;;;;;;;;;AAKO,IAAMC,OAAO,GAAG,SAAVA,OAAU,CAAAC,IAAI,EAAI;AAC7B,MAAMC,SAAS,GAAGD,IAAI,CAACE,KAAL,CAAW,GAAX,EAAgBC,KAAhB,CAAsB,CAAC,CAAvB,CAAlB;AACA,MAAMb,SAAS,GAAGW,SAAS,CAACA,SAAS,CAACG,MAAV,GAAmB,CAApB,CAAT,CAAgCF,KAAhC,CAAsC,GAAtC,EAA2CG,GAA3C,EAAlB;AACA,MAAMX,IAAI,GAAGL,QAAQ,CAACC,SAAD,CAArB;AAEA,SAAOI,IAAI,CAAC,CAAD,CAAX;AACD,CANM;AAQP;;;;;;;;;AAKO,IAAMY,YAAY,GAAG,SAAfA,YAAe,CAAAZ,IAAI;AAAA,SAAI,CAACN,SAAS,CAACM,IAAI,CAACa,WAAL,EAAD,CAAT,IAAiC,EAAlC,EAAsC,CAAtC,CAAJ;AAAA,CAAzB","sourcesContent":["const mimeTypes = {};\n\nconst findType = extension =>\n  Object.entries(mimeTypes).find(type => type[1].includes(extension)) || [];\n\nexport const addType = (mime, extensions) => {\n  mimeTypes[mime] = extensions;\n};\n\n/**\n * Lookup a mime type based on extension\n * @param {string} path path to find extension for\n * @returns {string} mime found mime type\n */\nexport const getType = path => {\n  const pathParts = path.split('/').slice(-1);\n  const extension = pathParts[pathParts.length - 1].split('.').pop();\n  const type = findType(extension);\n\n  return type[0];\n};\n\n/**\n * Return file extension associated with a mime type\n * @param {string} type mime type to look up\n * @returns {string} extension file extension\n */\nexport const getExtension = type => (mimeTypes[type.toLowerCase()] || [])[0];\n"],"file":"mime.js"}
\ No newline at end of file
diff --git a/node_modules/@jimp/core/es/utils/promisify.js b/node_modules/@jimp/core/es/utils/promisify.js
index a307532..c52bd50 100644
--- a/node_modules/@jimp/core/es/utils/promisify.js
+++ b/node_modules/@jimp/core/es/utils/promisify.js
@@ -1,27 +1,13 @@
-"use strict";
-
-Object.defineProperty(exports, "__esModule", {
-  value: true
-});
-exports["default"] = void 0;
-
-var promisify = function promisify(fun, ctx) {
-  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
-    args[_key - 2] = arguments[_key];
-  }
-
-  return new Promise(function (resolve, reject) {
-    args.push(function (err, data) {
+const promisify = (fun, ctx, ...args) =>
+  new Promise((resolve, reject) => {
+    args.push((err, data) => {
       if (err) {
         reject(err);
       }
 
       resolve(data);
     });
-    fun.bind(ctx).apply(void 0, args);
+    fun.bind(ctx)(...args);
   });
-};
 
-var _default = promisify;
-exports["default"] = _default;
-//# sourceMappingURL=promisify.js.map
\ No newline at end of file
+export default promisify;
diff --git a/node_modules/@jimp/core/es/utils/promisify.js.map b/node_modules/@jimp/core/es/utils/promisify.js.map
deleted file mode 100644
index c72c0c4..0000000
--- a/node_modules/@jimp/core/es/utils/promisify.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"sources":["../../src/utils/promisify.js"],"names":["promisify","fun","ctx","args","Promise","resolve","reject","push","err","data","bind"],"mappings":";;;;;;;AAAA,IAAMA,SAAS,GAAG,SAAZA,SAAY,CAACC,GAAD,EAAMC,GAAN;AAAA,oCAAcC,IAAd;AAAcA,IAAAA,IAAd;AAAA;;AAAA,SAChB,IAAIC,OAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV,EAAqB;AAC/BH,IAAAA,IAAI,CAACI,IAAL,CAAU,UAACC,GAAD,EAAMC,IAAN,EAAe;AACvB,UAAID,GAAJ,EAAS;AACPF,QAAAA,MAAM,CAACE,GAAD,CAAN;AACD;;AAEDH,MAAAA,OAAO,CAACI,IAAD,CAAP;AACD,KAND;AAOAR,IAAAA,GAAG,CAACS,IAAJ,CAASR,GAAT,gBAAiBC,IAAjB;AACD,GATD,CADgB;AAAA,CAAlB;;eAYeH,S","sourcesContent":["const promisify = (fun, ctx, ...args) =>\n  new Promise((resolve, reject) => {\n    args.push((err, data) => {\n      if (err) {\n        reject(err);\n      }\n\n      resolve(data);\n    });\n    fun.bind(ctx)(...args);\n  });\n\nexport default promisify;\n"],"file":"promisify.js"}
\ No newline at end of file
